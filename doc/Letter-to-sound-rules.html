<html lang="en">
<head>
<title>Letter to sound rules - Festival Speech Synthesis System</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Festival Speech Synthesis System">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Lexicons.html#Lexicons" title="Lexicons">
<link rel="prev" href="Lookup-process.html#Lookup-process" title="Lookup process">
<link rel="next" href="Building-letter-to-sound-rules.html#Building-letter-to-sound-rules" title="Building letter to sound rules">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Letter-to-sound-rules"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Building-letter-to-sound-rules.html#Building-letter-to-sound-rules">Building letter to sound rules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Lookup-process.html#Lookup-process">Lookup process</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Lexicons.html#Lexicons">Lexicons</a>
<hr>
</div>

<h3 class="section">13.4 Letter to sound rules</h3>

<p><a name="index-letter-to-sound-rules-163"></a>Each lexicon may define what action to take when a word cannot
be found in the addenda or the compiled lexicon.  There are
a number of options which will hopefully be added to as more
general letter to sound rule systems are added.

   <p><a name="index-unknown-words-164"></a>The method is set by the command
<pre class="lisp">     (lex.set.lts.method METHOD)
</pre>
   <p>Where <var>METHOD</var> can be any of the following
     <dl>
<dt>&lsquo;<samp><span class="samp">Error</span></samp>&rsquo;<dd>Throw an error when an unknown word is found (default). 
<br><dt>&lsquo;<samp><span class="samp">lts_rules</span></samp>&rsquo;<dd>Use externally specified set of letter to sound rules (described
below).  The name of the rule set to use is defined with the
<code>lex.lts.ruleset</code> function.  This method runs one
set of rules on an exploded form of the word and assumes the rules
return a list of phonemes (in the appropriate set).  If multiple
instances of rules are required use the <code>function</code> method
described next. 
<br><dt>&lsquo;<samp><span class="samp">none</span></samp>&rsquo;<dd>This returns an entry with a <code>nil</code> pronunciation field.  This will
only be valid in very special circumstances. 
<br><dt>&lsquo;<samp><span class="samp">FUNCTIONNAME</span></samp>&rsquo;<dd>Call this as a LISP function function name.    This function
is given two arguments: the word and the part of speech.  It should
return a valid lexical entry. 
</dl>

   <p>The basic letter to sound rule system is very simple but is
powerful enough to build reasonably complex letter to sound rules. 
Although we've found trained LTS rules better than hand written
ones (for complex languages) where no data is available and rules
must be hand written the following rule formalism is much easier to
use than that generated by the LTS training system (described
in the next section).

   <p><a name="index-letter-to-sound-rules-165"></a><a name="index-LTS-166"></a>The basic form of a rule is as follows
<pre class="lisp">     ( LEFTCONTEXT [ ITEMS ] RIGHTCONTEXT = NEWITEMS )
</pre>
   <p>This interpretation is that if <var>ITEMS</var> appear in the specified right
and left context then the output string is to contain <var>NEWITEMS</var>. 
Any of <var>LEFTCONTEXT</var>, <var>RIGHTCONTEXT</var> or <var>NEWITEMS</var> may be
empty.  Note that <var>NEWITEMS</var> is written to a different "tape" and hence
cannot feed further rules (within this ruleset).  An example is
<pre class="lisp">     ( # [ c h ] C = k )
</pre>
   <p>The special character <code>#</code> denotes a word boundary, and the symbol
<code>C</code> denotes the set of all consonants, sets are declared before
rules.  This rule states that a <code>ch</code> at the start of a word
followed by a consonant is to be rendered as the <code>k</code> phoneme. 
Symbols in contexts may be followed by the symbol <code>*</code> for zero or
more occurrences, or <code>+</code> for one or more occurrences.

   <p>The symbols in the rules are treated as set names if they are declared
as such or as symbols in the input/output alphabets.  The symbols
may be more than one character long and the names are case sensitive.

   <p>The rules are tried in order until one matches the first (or more)
symbol of the tape.  The rule is applied adding the right hand side to
the output tape.  The rules are again applied from the start of the list
of rules.

   <p>The function used to apply a set of rules if given an atom will explode
it into a list of single characters, while if given a list will use it
as is.  This reflects the common usage of wishing to re-write the
individual letters in a word to phonemes but without excluding the
possibility of using the system for more complex manipulations,
such as multi-pass LTS systems and phoneme conversion.

   <p>From lisp there are three basic access functions, there
are corresponding functions in the C/C++ domain.

     <dl>
<dt><code>(lts.ruleset NAME SETS RULES)</code><dd>Define a new set of lts rules.  Where <code>NAME</code> is the name for this
rule, SETS is a list of set definitions of the form <code>(SETNAME e0 e1
...)</code>  and <code>RULES</code> are a list of rules as described above. 
<br><dt><code>(lts.apply WORD RULESETNAME)</code><dd>Apply the set of rules named <code>RULESETNAME</code> to <code>WORD</code>.  If
<code>WORD</code> is a symbol it is exploded into a list of the individual
characters in its print name.  If <code>WORD</code> is a list it is used as
is.  If the rules cannot be successfully applied an error is given.  The
result of (successful) application is returned in a list. 
<br><dt><code>(lts.check_alpha WORD RULESETNAME)</code><dd>The symbols in <code>WORD</code> are checked against the input alphabet of the
rules named <code>RULESETNAME</code>.  If they are all contained in that
alphabet <code>t</code> is returned, else <code>nil</code>.  Note this does not
necessarily mean the rules will successfully apply (contexts may restrict
the application of the rules), but it allows general checking like
numerals, punctuation etc, allowing application of appropriate rule
sets. 
</dl>

   <p>The letter to sound rule system may be used directly from Lisp
and can easily be used to do relatively complex operations for
analyzing words without requiring modification of the C/C++
system.  For example the Welsh letter to sound rule system consists
or three rule sets, first to explicitly identify epenthesis, then
identify stressed vowels, and finally rewrite this augmented
letter string to phonemes.  This is achieved by
the following function
<pre class="lisp">     (define (welsh_lts word features)
       (let (epen str wel)
         (set! epen (lts.apply (downcase word) 'newepen))
         (set! str (lts.apply epen 'newwelstr))
         (set! wel (lts.apply str 'newwel))
         (list word
               nil
               (lex.syllabify.phstress wel))))
</pre>
   <p>The LTS method for the Welsh lexicon is set to <code>welsh_lts</code>, so this
function is called when a word is not found in the lexicon.  The
above function first downcases the word and then applies the rulesets in
turn, finally calling the syllabification process and returns a
constructed lexically entry.

   </body></html>

