<html lang="en">
<head>
<title>Building letter to sound rules - Festival Speech Synthesis System</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Festival Speech Synthesis System">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Lexicons.html#Lexicons" title="Lexicons">
<link rel="prev" href="Letter-to-sound-rules.html#Letter-to-sound-rules" title="Letter to sound rules">
<link rel="next" href="Lexicon-requirements.html#Lexicon-requirements" title="Lexicon requirements">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Building-letter-to-sound-rules"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Lexicon-requirements.html#Lexicon-requirements">Lexicon requirements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Letter-to-sound-rules.html#Letter-to-sound-rules">Letter to sound rules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Lexicons.html#Lexicons">Lexicons</a>
<hr>
</div>

<h3 class="section">13.5 Building letter to sound rules</h3>

<p>As writing letter to sound rules by hand is hard and very time
consuming, an alternative method is also available where a latter to
sound system may be built from a lexicon of the language.  This
technique has successfully been used from English (British and American),
French and German.  The difficulty and appropriateness of using
letter to sound rules is very language dependent,

   <p>The following outlines the processes involved in building a letter to
sound model for a language given a large lexicon of pronunciations. 
This technique is likely to work for most European languages (including
Russian) but doesn't seem particularly suitable for very language
alphabet languages like Japanese and Chinese.  The process described
here is not (yet) fully automatic but the hand intervention required is
small and may easily be done even by people with only a very little
knowledge of the language being dealt with.

   <p>The process involves the following steps
     <ul>
<li>Pre-processing lexicon into suitable training set
<li>Defining the set of allowable pairing of letters to phones.  (We intend
to do this fully automatically in future versions). 
<li>Constructing the probabilities of each letter/phone pair. 
<li>Aligning letters to an equal set of phones/_epsilons_. 
<li>Extracting the data by letter suitable for training. 
<li>Building CART models for predicting phone from letters (and context). 
<li>Building additional lexical stress assignment model (if necessary). 
</ul>
   All except the first two stages of this are fully automatic.

   <p>Before building a model its wise to think a little about what you want
it to do.  Ideally the model is an auxiluary to the lexicon so only
words not found in the lexicon will require use of the letter to sound
rules.  Thus only unusual forms are likely to require the rules.  More
precisely the most common words, often having the most non-standard
pronunciations, should probably be explicitly listed always.  It is
possible to reduce the size of the lexicon (sometimes drastically) by
removing all entries that the training LTS model correctly predicts.

   <p>Before starting it is wise to consider removing some entries from the
lexicon before training, I typically will remove words under 4 letters
and if part of speech information is available I remove all function
words, ideally only training from nouns verbs and adjectives as these
are the most likely forms to be unknown in text.  It is useful to have
morphologically inflected and derived forms in the training set as it is
often such variant forms that not found in the lexicon even though their
root morpheme is.  Note that in many forms of text, proper names are the
most common form of unknown word and even the technique presented here
may not adequately cater for that form of unknown words (especially if
they unknown words are non-native names).  This is all stating that this
may or may not be appropriate for your task but the rules generated by
this learning process have in the examples we've done been much better
than what we could produce by hand writing rules of the form described
in the previous section.

   <p>First preprocess the lexicon into a file of lexical entries to be used
for training, removing functions words and changing the head words to
all lower case (may be language dependent).  The entries should be of
the form used for input for Festival's lexicon compilation.  Specifical
the pronunciations should be simple lists of phones (no
syllabification).  Depending on the language, you may wish to remve the
stressing&mdash;for examples here we have though later tests suggest that we
should keep it in even for English.  Thus the training set should look
something like
<pre class="lisp">     ("table" nil (t ei b l))
     ("suspicious" nil (s @ s p i sh @ s))
</pre>
   <p>It is best to split the data into a training set and a test set
if you wish to know how well your training has worked.  In our
tests we remove every tenth entry and put it in a test set.  Note this
will mean our test results are probably better than if we removed
say the last ten in every hundred.

   <p>The second stage is to define the set of allowable letter to phone
mappings irrespective of context.  This can sometimes be initially done
by hand then checked against the training set.  Initially constract a
file of the form
<pre class="lisp">     (require 'lts_build)
     (set! allowables
           '((a _epsilon_)
             (b _epsilon_)
             (c _epsilon_)
             ...
             (y _epsilon_)
             (z _epsilon_)
             (# #)))
</pre>
   <p>All letters that appear in the alphabet should (at least) map to
<code>_epsilon_</code>, including any accented characters that appear in that
language.  Note the last two hashes.  These are used by to denote
beginning and end of word and are automatically added during training,
they must appear in the list and should only map to themselves.

   <p>To incrementally add to this allowable list run festival as
<pre class="lisp">     festival allowables.scm
</pre>
   <p>and at the prompt type
<pre class="lisp">     festival&gt; (cummulate-pairs "oald.train")
</pre>
   <p>with your train file.  This will print out each lexical entry
that couldn't be aligned with the current set of allowables.  At the
start this will be every entry.  Looking at these entries add
to the allowables to make alignment work.  For example if the
following word fails
<pre class="lisp">     ("abate" nil (ah b ey t))
</pre>
   <p>Add <code>ah</code> to the allowables for letter <code>a</code>, <code>b</code> to
<code>b</code>, <code>ey</code> to <code>a</code> and <code>t</code> to letter <code>t</code>.  After
doing that restart festival and call <code>cummulate-pairs</code> again. 
Incrementally add to the allowable pairs until the number of failures
becomes accceptable.  Often there are entries for which there is no real
relationship between the letters and the pronunciation such as in
abbreviations and foreign words (e.g. "aaa" as "t r ih p ax l ey").  For
the lexicons I've used the technique on less than 10 per thousand fail
in this way.

   <p>It is worth while being consistent on defining your set of allowables. 
(At least) two mappings are possible for the letter sequence
<code>ch</code>&mdash;having letter <code>c</code> go to phone <code>ch</code> and letter
<code>h</code> go to <code>_epsilon_</code> and also letter <code>c</code> go to phone
<code>_epsilon_</code> and letter <code>h</code> goes to <code>ch</code>.  However only
one should be allowed, we preferred <code>c</code> to <code>ch</code>.

   <p>It may also be the case that some letters give rise to more than one
phone.  For example the letter <code>x</code> in English is often pronunced as
the phone combination <code>k</code> and <code>s</code>.  To allow this, use the
multiphone <code>k-s</code>.  Thus the multiphone <code>k-s</code> will be predicted
for <code>x</code> in some context and the model will separate it into two
phones while it also ignoring any predicted <code>_epsilons_</code>.  Note that
multiphone units are relatively rare but do occur.  In English, letter
<code>x</code> give rise to a few, <code>k-s</code> in <code>taxi</code>, <code>g-s</code> in
<code>example</code>, and sometimes <code>g-zh</code> and <code>k-sh</code> in
<code>luxury</code>.  Others are <code>w-ah</code> in <code>one</code>, <code>t-s</code> in
<code>pizza</code>, <code>y-uw</code> in <code>new</code> (British), <code>ah-m</code> in
<code>-ism</code> etc.  Three phone multiphone are much rarer but may exist, they
are not supported by this code as is, but such entries should probably
be ignored.  Note the <code>-</code> sign in the multiphone examples is
significant and is used to indentify multiphones.

   <p>The allowables for OALD end up being
<pre class="lisp">     (set! allowables
            '
           ((a _epsilon_ ei aa a e@ @ oo au o i ou ai uh e)
            (b _epsilon_ b )
            (c _epsilon_ k s ch sh @-k s t-s)
            (d _epsilon_ d dh t jh)
            (e _epsilon_ @ ii e e@ i @@ i@ uu y-uu ou ei aa oi y y-u@ o)
            (f _epsilon_ f v )
            (g _epsilon_ g jh zh th f ng k t)
            (h _epsilon_ h @ )
            (i _epsilon_ i@ i @ ii ai @@ y ai-@ aa a)
            (j _epsilon_ h zh jh i y )
            (k _epsilon_ k ch )
            (l _epsilon_ l @-l l-l)
            (m _epsilon_ m @-m n)
            (n _epsilon_ n ng n-y )
            (o _epsilon_ @ ou o oo uu u au oi i @@ e uh w u@ w-uh y-@)
            (p _epsilon_ f p v )
            (q _epsilon_ k )
            (r _epsilon_ r @@ @-r)
            (s _epsilon_ z s sh zh )
            (t _epsilon_ t th sh dh ch d )
            (u _epsilon_ uu @ w @@ u uh y-uu u@ y-u@ y-u i y-uh y-@ e)
            (v _epsilon_ v f )
            (w _epsilon_ w uu v f u)
            (x _epsilon_ k-s g-z sh z k-sh z g-zh )
            (y _epsilon_ i ii i@ ai uh y @ ai-@)
            (z _epsilon_ z t-s s zh )
            (# #)
            ))
</pre>
   <p>Note this is an exhaustive list and (deliberately) says nothing
about the contexts or frequency that these letter to phone pairs appear. 
That information will be generated automatically from the training
set.

   <p>Once the number of failed matches is signficantly low enough
let <code>cummulate-pairs</code> run to completion.  This counts the number
of times each letter/phone pair occurs in allowable alignments.

   <p>Next call
<pre class="lisp">     festival&gt; (save-table "oald-")
</pre>
   <p>with the name of your lexicon.  This changes the cummulation
table into probabilities and saves it.

   <p>Restart festival loading this new table
<pre class="lisp">     festival allowables.scm oald-pl-table.scm
</pre>
   <p>Now each word can be aligned to an equally-lengthed string of phones,
epsilon and multiphones.
<pre class="lisp">     festival&gt; (aligndata "oald.train" "oald.train.align")
</pre>
   <p>Do this also for you test set.

   <p>This will produce entries like
<pre class="lisp">     aaronson _epsilon_ aa r ah n s ah n
     abandon ah b ae n d ah n
     abate ah b ey t _epsilon_
     abbe ae b _epsilon_ iy
</pre>
   <p>The next stage is to build features suitable for <samp><span class="file">wagon</span></samp> to
build models.  This is done by
<pre class="lisp">     festival&gt; (build-feat-file "oald.train.align" "oald.train.feats")
</pre>
   <p>Again the same for the test set.

   <p>Now you
need to constructrure a description file for <samp><span class="file">wagon</span></samp> for
the given data.  The can be done using the script <samp><span class="file">make_wgn_desc</span></samp>
provided with the speech tools

   <p>Here is an example script for building the models, you will need
to modify it for your particualr database but it shows the basic
processes
<pre class="example">     for i in a b c d e f g h i j k l m n o p q r s t u v w x y z
     do
        # Stop value for wagon
        STOP=2
        echo letter $i STOP $STOP
        # Find training set for letter $i
        cat oald.train.feats |
         awk '{if ($6 == "'$i'") print $0}' &gt;ltsdataTRAIN.$i.feats
        # split training set to get heldout data for stepwise testing
        traintest ltsdataTRAIN.$i.feats
        # Extract test data for letter $i
        cat oald.test.feats |
         awk '{if ($6 == "'$i'") print $0}' &gt;ltsdataTEST.$i.feats
        # run wagon to predict model
        wagon -data ltsdataTRAIN.$i.feats.train -test ltsdataTRAIN.$i.feats.test \
               -stepwise -desc ltsOALD.desc -stop $STOP -output lts.$i.tree
        # Test the resulting tree against
        wagon_test -heap 2000000 -data ltsdataTEST.$i.feats -desc ltsOALD.desc \
                   -tree lts.$i.tree
     done
</pre>
   <p>The script <samp><span class="file">traintest</span></samp> splits the given file <samp><span class="file">X</span></samp> into <samp><span class="file">X.train</span></samp>
and <samp><span class="file">X.test</span></samp> with every tenth line in <samp><span class="file">X.test</span></samp> and the rest
in <samp><span class="file">X.train</span></samp>.

   <p>This script can take a significnat amount of time to run, about 6 hours
on a Sun Ultra 140.

   <p>Once the models are created the must be collected together into
a single list structure.  The trees generated by <samp><span class="file">wagon</span></samp>
contain fully probability distributions at each leaf, at this time
this information can be removed as only the most probable will
actually be predicted.  This substantially reduces the size of the
tress.
<pre class="lisp">     (merge_models 'oald_lts_rules "oald_lts_rules.scm")
</pre>
   <p>(<code>merge_models</code> is defined within <samp><span class="file">lts_build.scm</span></samp>)
The given file will contain a <code>set!</code> for the given variable
name to an assoc list of letter to trained tree.  Note the above
function naively assumes that the letters in the alphabet are
the 26 lower case letters of the English alphabet, you will need
to edit this adding accented letters if required.  Note that
adding "'" (single quote) as a letter is a little tricky in scheme
but can be done&mdash;the command <code>(intern "'")</code> will give you
the symbol for single quote.

   <p>To test a set of lts models load the saved model and call
the following function with the test align file
<pre class="lisp">     festival oald-table.scm oald_lts_rules.scm
     festival&gt; (lts_testset "oald.test.align" oald_lts_rules)
</pre>
   <p>The result (after showing all the failed ones), will be a table showing
the results for each letter, for all letters and for complete words. 
The failed entries may give some notion of how good or bad the result
is, sometimes it will be simple vowel diferences, long versus short,
schwa versus full vowel, other times it may be who consonants missing. 
Remember the ultimate quality of the letter sound rules is how adequate
they are at providing <em>acceptable</em> pronunciations rather than
how good the numeric score is.

   <p><a name="index-stress-assignment-167"></a><a name="index-predicting-stress-168"></a>For some languages (e.g. English) it is necessary to also find a
stree pattern for unknown words.  Ultimately for this to work well
you need to know the morphological decomposition of the word. 
At present we provide a CART trained system to predict stress
patterns for English.  If does get 94.6% correct for an unseen test
set but that isn't really very good.  Later tests suggest that
predicting stressed and unstressed phones directly is actually
better for getting whole words correct even though the models
do slightly worse on a per phone basis <cite>black98</cite>.

   <p><a name="index-compressing-the-lexicon-169"></a><a name="index-reducing-the-lexicon-170"></a><a name="index-lexicon-compression-171"></a>As the lexicon may be a large part of the system we have also
experimented with removing entries from the lexicon if the letter to
sound rules system (and stree assignment system) can correct predict
them.  For OALD this allows us to half the size of the lexicon, it could
possibly allow more if a certain amount of fuzzy acceptance was allowed
(e.g. with schwa).  For other languages the gain here can be very
signifcant, for German and French we can reduce the lexicon by over 90%. 
The function <code>reduce_lexicon</code> in <samp><span class="file">festival/lib/lts_build.scm</span></samp>
was used to do this.  A diccussion of using the above technique as a
dictionary compression method is discussed in <cite>pagel98</cite>.  A
morphological decomposition algorithm, like that described in
<cite>black91</cite>, may even help more.

   <p>The technique described in this section and its relative merits with
respect to a number of languages/lexicons and tasks is dicussed more
fully in <cite>black98</cite>.

   </body></html>

