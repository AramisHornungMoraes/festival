<!doctype html>
<html>
<head>
<title>me_mlsa.cc</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Value stored to 'xrand' is never read -->

<!-- BUGTYPE Dead assignment -->

<!-- BUGCATEGORY Dead store -->

<!-- BUGFILE /media/dades/src/festival-2013/festival/src/modules/clustergen/me_mlsa.cc -->

<!-- BUGLINE 349 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>modules/clustergen/me_mlsa.cc</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 349, column 5</a></td></tr>
<tr><td class="rowname">Description:</td><td>Value stored to 'xrand' is never read</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/**</span>   </td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"><span class='comment'>*           The HMM-Based Speech Synthesis System (HTS)</span>             </td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"><span class='comment'>*                       HTS Working Group</span>                           </td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"><span class='comment'>*                  Department of Computer Science</span>                   </td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"><span class='comment'>*                  Nagoya Institute of Technology</span>                   </td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"><span class='comment'>*                               and</span>                                 </td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"><span class='comment'>*   Interdisciplinary Graduate School of Science and Engineering</span>    </td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"><span class='comment'>*                  Tokyo Institute of Technology</span>                    </td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"><span class='comment'>*                Portions Copyright (c) 2001-2006</span>                       </td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"><span class='comment'>*                       All Rights Reserved.</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"><span class='comment'>*</span>                         </td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='comment'>*              Portions Copyright 2000-2007 DFKI GmbH.</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"><span class='comment'>*                      All Rights Reserved.</span>                  </td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"><span class='comment'>*  Permission is hereby granted, free of charge, to use and</span>         </td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"><span class='comment'>*  distribute this software and its documentation without</span>           </td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"><span class='comment'>*  restriction, including without limitation the rights to use,</span>     </td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='comment'>*  copy, modify, merge, publish, distribute, sublicense, and/or</span>     </td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"><span class='comment'>*  sell copies of this work, and to permit persons to whom this</span>     </td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='comment'>*  work is furnished to do so, subject to the following conditions:</span> </td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"><span class='comment'>*    1. The source code must retain the above copyright notice,</span>     </td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"><span class='comment'>*       this list of conditions and the following disclaimer.</span>       </td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"><span class='comment'>*    2. Any modifications to the source code must be clearly</span>        </td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"><span class='comment'>*       marked as such.</span>                                             </td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"><span class='comment'>*    3. Redistributions in binary form must reproduce the above</span>     </td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"><span class='comment'>*       copyright notice, this list of conditions and the</span>           </td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='comment'>*       following disclaimer in the documentation and/or other</span>      </td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"><span class='comment'>*       materials provided with the distribution.  Otherwise, one</span>   </td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"><span class='comment'>*       must contact the HTS working group.</span>                         </td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"><span class='comment'>*  NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSTITUTE OF TECHNOLOGY,</span>   </td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='comment'>*  HTS WORKING GROUP, AND THE CONTRIBUTORS TO THIS WORK DISCLAIM</span>    </td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"><span class='comment'>*  ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL</span>       </td></tr>
<tr><td class="num" id="LN39">39</td><td class="line"><span class='comment'>*  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT</span>   </td></tr>
<tr><td class="num" id="LN40">40</td><td class="line"><span class='comment'>*  SHALL NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSTITUTE OF</span>         </td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"><span class='comment'>*  TECHNOLOGY, HTS WORKING GROUP, NOR THE CONTRIBUTORS BE LIABLE</span>    </td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"><span class='comment'>*  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY</span>        </td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"><span class='comment'>*  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>  </td></tr>
<tr><td class="num" id="LN44">44</td><td class="line"><span class='comment'>*  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTUOUS</span>   </td></tr>
<tr><td class="num" id="LN45">45</td><td class="line"><span class='comment'>*  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</span>          </td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"><span class='comment'>*  PERFORMANCE OF THIS SOFTWARE.</span>                                    </td></tr>
<tr><td class="num" id="LN47">47</td><td class="line"><span class='comment'>*</span>                                                                   </td></tr>
<tr><td class="num" id="LN48">48</td><td class="line"><span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN49">49</td><td class="line"><span class='comment'>*  This software was translated to C for use within Festival to offer</span></td></tr>
<tr><td class="num" id="LN50">50</td><td class="line"><span class='comment'>*  multi-excitation MLSA</span></td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"><span class='comment'>*            Alan W Black (awb@cs.cmu.edu) 3rd April 2009</span></td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"><span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line"> </td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"><span class='directive'>#include &lt;stdio.h&gt;</span></td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"><span class='directive'>#include &lt;stdlib.h&gt;</span></td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"><span class='directive'>#include &lt;string.h&gt;</span></td></tr>
<tr><td class="num" id="LN58">58</td><td class="line"><span class='directive'>#include &lt;math.h&gt;</span></td></tr>
<tr><td class="num" id="LN59">59</td><td class="line"><span class='directive'>#include &lt;EST_walloc.h&gt;</span></td></tr>
<tr><td class="num" id="LN60">60</td><td class="line"><span class='directive'>#include "festival.h"</span></td></tr>
<tr><td class="num" id="LN61">61</td><td class="line"> </td></tr>
<tr><td class="num" id="LN62">62</td><td class="line"><span class='directive'>#include "mlsa_resynthesis.h"</span></td></tr>
<tr><td class="num" id="LN63">63</td><td class="line"> </td></tr>
<tr><td class="num" id="LN64">64</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr><td class="num" id="LN65">65</td><td class="line"> <span class='comment'>* Synthesis of speech out of speech parameters.</span></td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"> <span class='comment'>* Mixed excitation MLSA vocoder.</span> </td></tr>
<tr><td class="num" id="LN67">67</td><td class="line"> <span class='comment'>*</span> </td></tr>
<tr><td class="num" id="LN68">68</td><td class="line"> <span class='comment'>* Java port and extension of HTS engine version 2.0</span></td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"> <span class='comment'>* Extension: mixed excitation</span></td></tr>
<tr><td class="num" id="LN70">70</td><td class="line"> <span class='comment'>* @author Marcela Charfuelan</span> </td></tr>
<tr><td class="num" id="LN71">71</td><td class="line"> <span class='comment'>* And ported to C by Alan W Black (awb@cs.cmu.edu)</span></td></tr>
<tr><td class="num" id="LN72">72</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN73">73</td><td class="line"> </td></tr>
<tr><td class="num" id="LN74">74</td><td class="line"><span class='directive'>#define <span class='macro'>boolean<span class='expansion'>int</span></span> int</span></td></tr>
<tr><td class="num" id="LN75">75</td><td class="line"><span class='directive'>#define <span class='macro'>true<span class='expansion'>1</span></span> 1</span></td></tr>
<tr><td class="num" id="LN76">76</td><td class="line"><span class='directive'>#define <span class='macro'>false<span class='expansion'>0</span></span> 0</span></td></tr>
<tr><td class="num" id="LN77">77</td><td class="line"> </td></tr>
<tr><td class="num" id="LN78">78</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> HTSData_struct {</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">    <span class='keyword'>int</span> rate;</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">    <span class='keyword'>int</span> fperiod;</td></tr>
<tr><td class="num" id="LN82">82</td><td class="line">    <span class='keyword'>double</span> rhos;</td></tr>
<tr><td class="num" id="LN83">83</td><td class="line"> </td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">    <span class='keyword'>int</span> stage;</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">    <span class='keyword'>double</span> alpha;</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">    <span class='keyword'>double</span> beta;</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useLogGain;</td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">    <span class='keyword'>double</span> uf;</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> algnst; <span class='comment'>/* use state level alignment for duration     */</span></td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> algnph; <span class='comment'>/* use phoneme level alignment for duration   */</span></td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useMixExc;  <span class='comment'>/* use Mixed Excitation */</span></td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useFourierMag; <span class='comment'>/* use Fourier magnitudes for pulse generation */</span></td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useGV; <span class='comment'>/* use global variance in parameter generation */</span></td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useGmmGV; <span class='comment'>/* use global variance as a Gaussian Mixture Model */</span></td></tr>
<tr><td class="num" id="LN95">95</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useUnitDurationContinuousFeature; <span class='comment'>/* for using external duration, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useUnitLogF0ContinuousFeature;    <span class='comment'>/* for using external f0, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">    </td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">    <span class='comment'>/** variables for controling generation of speech in the vocoder</span>       </td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">     <span class='comment'>* these variables have default values but can be fixed and read from the</span></td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">     <span class='comment'>* audio effects component. [Default][min--max]   */</span></td></tr>
<tr><td class="num" id="LN101">101</td><td class="line">    <span class='keyword'>double</span> length;   <span class='comment'>/* total number of frame for generated speech */</span></td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">            <span class='comment'>/* length of generated speech (in seconds)   [N/A][0.0--30.0]  */</span></td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">    <span class='keyword'>double</span> durationScale; <span class='comment'>/* less than 1.0 is faster and more than 1.0 is slower, min=0.1 max=3.0 */</span></td></tr>
<tr><td class="num" id="LN104">104</td><td class="line"> </td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> LogGain;</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">    <span class='keyword'>char</span> *PdfStrFile, *PdfMagFile;</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">    </td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">    <span class='keyword'>int</span> NumFilters, OrderFilters;</td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">    <span class='keyword'>double</span> **MixFilters;</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line">    <span class='keyword'>double</span> F0Std;</td></tr>
<tr><td class="num" id="LN111">111</td><td class="line">    <span class='keyword'>double</span> F0Mean;</td></tr>
<tr><td class="num" id="LN112">112</td><td class="line"> </td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">} HTSData;</td></tr>
<tr><td class="num" id="LN114">114</td><td class="line"> </td></tr>
<tr><td class="num" id="LN115">115</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN116">116</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> HTSData_struct {</td></tr>
<tr><td class="num" id="LN117">117</td><td class="line"> </td></tr>
<tr><td class="num" id="LN118">118</td><td class="line">    <span class='keyword'>int</span> rate = 16000;</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line">    <span class='keyword'>int</span> fperiod = 80;</td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">    <span class='keyword'>double</span> rhos = 0.0;</td></tr>
<tr><td class="num" id="LN121">121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">    <span class='keyword'>int</span> stage = 0;</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line">    <span class='keyword'>double</span> alpha = 0.42;</td></tr>
<tr><td class="num" id="LN124">124</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useLogGain = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">    <span class='keyword'>double</span> uf = 0.5;</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> algnst = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use state level alignment for duration     */</span></td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> algnph = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use phoneme level alignment for duration   */</span></td></tr>
<tr><td class="num" id="LN128">128</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useMixExc     = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;  <span class='comment'>/* use Mixed Excitation */</span></td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useFourierMag = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use Fourier magnitudes for pulse generation */</span></td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useGV = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use global variance in parameter generation */</span></td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useGmmGV = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use global variance as a Gaussian Mixture Model */</span></td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useUnitDurationContinuousFeature = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* for using external duration, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> useUnitLogF0ContinuousFeature = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;    <span class='comment'>/* for using external f0, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN134">134</td><td class="line">    </td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">    <span class='comment'>/** variables for controling generation of speech in the vocoder</span>       </td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">     <span class='comment'>* these variables have default values but can be fixed and read from the</span></td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">     <span class='comment'>* audio effects component. [Default][min--max]   */</span></td></tr>
<tr><td class="num" id="LN138">138</td><td class="line">    <span class='keyword'>double</span> f0Std   = 1.0;   <span class='comment'>/* variable for f0 control, multiply f0  [1.0][0.0--5.0]   */</span></td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">    <span class='keyword'>double</span> f0Mean  = 0.0;   <span class='comment'>/* variable for f0 control, add f0 [0.0][0.0--100.0] */</span></td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">    <span class='keyword'>double</span> length  = 0.0;   <span class='comment'>/* total number of frame for generated speech */</span></td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">            <span class='comment'>/* length of generated speech (in seconds)   [N/A][0.0--30.0]  */</span></td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">    <span class='keyword'>double</span> durationScale = 1.0; <span class='comment'>/* less than 1.0 is faster and more than 1.0 is slower, min=0.1 max=3.0 */</span></td></tr>
<tr><td class="num" id="LN143">143</td><td class="line"> </td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">} HTSData;</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN146">146</td><td class="line"> </td></tr>
<tr><td class="num" id="LN147">147</td><td class="line"><span class='keyword'>static</span>  <span class='keyword'>int</span> IPERIOD = 1;</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> GAUSS = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;</td></tr>
<tr><td class="num" id="LN149">149</td><td class="line"><span class='keyword'>static</span>  <span class='keyword'>int</span> PADEORDER = 5;       <span class='comment'>/* pade order for MLSA filter */</span></td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"><span class='keyword'>static</span>  <span class='keyword'>int</span> IRLENG    = 96;      <span class='comment'>/* length of impulse response */</span></td></tr>
<tr><td class="num" id="LN151">151</td><td class="line">    </td></tr>
<tr><td class="num" id="LN152">152</td><td class="line"><span class='comment'>/* for MGLSA filter (mel-generalised log spectrum approximation filter) */</span></td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> NORMFLG1 = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;</td></tr>
<tr><td class="num" id="LN154">154</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> NORMFLG2 = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> MULGFLG1 = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;</td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> MULGFLG2 = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN157">157</td><td class="line"><span class='keyword'>static</span>  <span class='macro'>boolean<span class='expansion'>int</span></span> NGAIN    = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN158">158</td><td class="line">    </td></tr>
<tr><td class="num" id="LN159">159</td><td class="line"><span class='keyword'>static</span>  <span class='keyword'>double</span> ZERO  = 1.0e-10;            <span class='comment'>/* ~(0) */</span></td></tr>
<tr><td class="num" id="LN160">160</td><td class="line"><span class='keyword'>static</span>  <span class='keyword'>double</span> LZERO = (-1.0e+10);         <span class='comment'>/* ~log(0) */</span></td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">    </td></tr>
<tr><td class="num" id="LN162">162</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> stage;             <span class='comment'>/* Gamma=-1/stage : if stage=0 then Gamma=0 */</span></td></tr>
<tr><td class="num" id="LN163">163</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> xgamma;          <span class='comment'>/* Gamma */</span></td></tr>
<tr><td class="num" id="LN164">164</td><td class="line"><span class='keyword'>static</span> <span class='macro'>boolean<span class='expansion'>int</span></span> use_log_gain;  <span class='comment'>/* log gain flag (for LSP) */</span></td></tr>
<tr><td class="num" id="LN165">165</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> fprd;              <span class='comment'>/* frame shift */</span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> iprd;              <span class='comment'>/* interpolation period */</span></td></tr>
<tr><td class="num" id="LN167">167</td><td class="line"><span class='keyword'>static</span> <span class='macro'>boolean<span class='expansion'>int</span></span> gauss;         <span class='comment'>/* flag to use Gaussian noise */</span></td></tr>
<tr><td class="num" id="LN168">168</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> p1;             <span class='comment'>/* used in excitation generation */</span></td></tr>
<tr><td class="num" id="LN169">169</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> pc;             <span class='comment'>/* used in excitation generation */</span></td></tr>
<tr><td class="num" id="LN170">170</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *pade;         <span class='comment'>/* used in mlsadf */</span></td></tr>
<tr><td class="num" id="LN171">171</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ppade;             <span class='comment'>/* offset for vector ppade */</span>  </td></tr>
<tr><td class="num" id="LN172">172</td><td class="line"> </td></tr>
<tr><td class="num" id="LN173">173</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *C;            <span class='comment'>/* used in the MLSA/MGLSA filter */</span></td></tr>
<tr><td class="num" id="LN174">174</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *CC;           <span class='comment'>/* used in the MLSA/MGLSA filter */</span></td></tr>
<tr><td class="num" id="LN175">175</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *CINC;         <span class='comment'>/* used in the MLSA/MGLSA filter */</span></td></tr>
<tr><td class="num" id="LN176">176</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *D1;           <span class='comment'>/* used in the MLSA/MGLSA filter */</span></td></tr>
<tr><td class="num" id="LN177">177</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> CINC_length, CC_length, C_length, D1_length;</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line"> </td></tr>
<tr><td class="num" id="LN179">179</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> rate;</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> pt1;                            <span class='comment'>/* used in mlsadf1 */</span></td></tr>
<tr><td class="num" id="LN181">181</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> pt2;                            <span class='comment'>/* used in mlsadf2 */</span></td></tr>
<tr><td class="num" id="LN182">182</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> *pt3;                          <span class='comment'>/* used in mlsadf2 */</span></td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">    </td></tr>
<tr><td class="num" id="LN184">184</td><td class="line"><span class='comment'>/* mixed excitation variables */</span>  </td></tr>
<tr><td class="num" id="LN185">185</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> numM;           <span class='comment'>/* Number of bandpass filters for mixed excitation */</span></td></tr>
<tr><td class="num" id="LN186">186</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> orderM;         <span class='comment'>/* Order of filters for mixed excitation */</span></td></tr>
<tr><td class="num" id="LN187">187</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> **h;              <span class='comment'>/* filters for mixed excitation */</span>  </td></tr>
<tr><td class="num" id="LN188">188</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *xpulseSignal;     <span class='comment'>/* the size of this should be orderM */</span></td></tr>
<tr><td class="num" id="LN189">189</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *xnoiseSignal;     <span class='comment'>/* the size of this should be orderM */</span></td></tr>
<tr><td class="num" id="LN190">190</td><td class="line"><span class='keyword'>static</span> <span class='macro'>boolean<span class='expansion'>int</span></span> mixedExcitation   = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line"><span class='keyword'>static</span> <span class='macro'>boolean<span class='expansion'>int</span></span> fourierMagnitudes = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">    </td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"><span class='keyword'>static</span> <span class='macro'>boolean<span class='expansion'>int</span></span> lpcVocoder        = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;     <span class='comment'>/* true if lpc vocoder is used, then the input should be lsp parameters */</span></td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN195">195</td><td class="line"><span class='keyword'>void</span> initVocoder(<span class='keyword'>int</span> mcep_order, <span class='keyword'>int</span> mcep_vsize, HTSData *htsData);</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line"><span class='keyword'>int</span>  htsMLSAVocoder(EST_Track *lf0Pst, </td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">                    EST_Track *mcepPst, </td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">                    EST_Track *strPst, </td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">                    EST_Track *magPst, </td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">                    <span class='keyword'>int</span> *voiced,</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">                    HTSData *htsData,</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">                    EST_Wave *wave);</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line"> </td></tr>
<tr><td class="num" id="LN204">204</td><td class="line"> </td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">LISP me_mlsa_resynthesis(LISP ltrack, LISP strack)</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">{</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">    <span class='comment'>/* Resynthesizes a wave from given track with mixed excitation*/</span></td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">    EST_Track *t;</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">    EST_Track *str_track;</td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">    EST_Wave *wave = 0;</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">    EST_Track *mcep;</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">    EST_Track *f0v;</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">    EST_Track *str;</td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">    EST_Track *mag;</td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">    <span class='keyword'>int</span> *voiced;</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">    <span class='keyword'>int</span> sr = 16000;</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">    <span class='keyword'>int</span> i,j;</td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">    <span class='keyword'>double</span> shift;</td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">    HTSData htsData;</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line"> </td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">    htsData.alpha = 0.42;</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">    htsData.beta = 0.0;</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line"> </td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">    <span class='keyword'>if</span> ((ltrack == <span class='macro'>NULL<span class='expansion'>__null</span></span>) ||</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line">        (<span class='macro'>TYPEP(ltrack,tc_string)<span class='expansion'>( (ltrack != __null) &amp;&amp; ((((ltrack) == ((struct obj *<br>) 0)) ? 0 : ((*(ltrack)).type)) == (13)) )</span></span> &amp;&amp;</td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">         (<span class='macro'>streq(get_c_string(ltrack),<span class='string_literal'>"nil"</span>)<span class='expansion'>(strcmp(get_c_string(ltrack),"nil")==0)</span></span>)))</td></tr>
<tr><td class="num" id="LN227">227</td><td class="line">        <span class='keyword'>return</span> siod(<span class='keyword'>new</span> EST_Wave(0,1,sr));</td></tr>
<tr><td class="num" id="LN228">228</td><td class="line"> </td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">    t = track(ltrack);</td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">    str_track = track(strack);</td></tr>
<tr><td class="num" id="LN231">231</td><td class="line"> </td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">    f0v = <span class='keyword'>new</span> EST_Track(t-&gt;num_frames(),1);</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">    mcep = <span class='keyword'>new</span> EST_Track(t-&gt;num_frames(),25);</td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">    str = <span class='keyword'>new</span> EST_Track(t-&gt;num_frames(),5);</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">    mag = <span class='keyword'>new</span> EST_Track(t-&gt;num_frames(),10);</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">    voiced = <span class='macro'>walloc(<span class='keyword'>int</span>,t-&gt;num_frames())<span class='expansion'>((int *)safe_walloc(sizeof(int)*(t-&gt;num_frames())))</span></span>;</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line"> </td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">    <span class='keyword'>for</span> (i=0; i&lt;t-&gt;num_frames(); i++)</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">    {</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">        f0v-&gt;a(i) = t-&gt;a(i,0);</td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">        <span class='keyword'>if</span> (f0v-&gt;a(i) &gt; 0)</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">            voiced[i] = 1;</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">        <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">            voiced[i] = 0;</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">        <span class='keyword'>for</span> (j=1; j&lt;26; j++)</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">            mcep-&gt;a(i,j-1) = t-&gt;a(i,j);</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line"> </td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">        <span class='keyword'>for</span> (j=0; j&lt;5; j++)</td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">        {</td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">            str-&gt;a(i,j) = str_track-&gt;a(i,j);</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">        <span class='comment'>/*        printf("awb_debug str %d 0 %f 1 %f 2 %f 3 %f 4 %f\n",</span></td></tr>
<tr><td class="num" id="LN253">253</td><td class="line">            <span class='comment'>i,str-&gt;a(i,0),str-&gt;a(i,1),str-&gt;a(i,2),str-&gt;a(i,3),str-&gt;a(i,4));*/</span></td></tr>
<tr><td class="num" id="LN254">254</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN255">255</td><td class="line">        <span class='keyword'>for</span> (j=57; j&lt;66; j++)</td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">            mag-&gt;a(i,j-57) = t-&gt;a(i,j);</td></tr>
<tr><td class="num" id="LN257">257</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line"> </td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">    <span class='keyword'>if</span> (t-&gt;num_frames() &gt; 1)</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">        shift = 1000.0*(t-&gt;t(1)-t-&gt;t(0));</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN263">263</td><td class="line">        shift = 5.0;</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line"> </td></tr>
<tr><td class="num" id="LN265">265</td><td class="line">    htsData.alpha = <span class='macro'>FLONM(siod_get_lval(<span class='string_literal'>"mlsa_alpha_param"</span>,<span class='expansion'>((*siod_get_lval("mlsa_alpha_param", "mlsa: mlsa_alpha_param not set"<br>)).storage_as.flonum.data)</span></span></td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">                                        <span class='string_literal'><span class='macro'>"mlsa: mlsa_alpha_param not set"</span>))<span class='expansion'>((*siod_get_lval("mlsa_alpha_param", "mlsa: mlsa_alpha_param not set"<br>)).storage_as.flonum.data)</span></span>;</td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">    htsData.beta = <span class='macro'>FLONM(siod_get_lval(<span class='string_literal'>"mlsa_beta_param"</span>,<span class='expansion'>((*siod_get_lval("mlsa_beta_param", "mlsa: mlsa_beta_param not set"<br>)).storage_as.flonum.data)</span></span></td></tr>
<tr><td class="num" id="LN268">268</td><td class="line">                                       <span class='string_literal'><span class='macro'>"mlsa: mlsa_beta_param not set"</span>))<span class='expansion'>((*siod_get_lval("mlsa_beta_param", "mlsa: mlsa_beta_param not set"<br>)).storage_as.flonum.data)</span></span>;</td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">    htsData.stage = 0;</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">    htsData.LogGain = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">    htsData.fperiod = 80;</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line">    htsData.rate = 16000;</td></tr>
<tr><td class="num" id="LN273">273</td><td class="line">    htsData.rhos = 0.0;</td></tr>
<tr><td class="num" id="LN274">274</td><td class="line"> </td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">    htsData.uf = 0.5;</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">    htsData.algnst = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use state level alignment for duration     */</span></td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">    htsData.algnph = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use phoneme level alignment for duration   */</span></td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">    htsData.useMixExc     = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;  <span class='comment'>/* use Mixed Excitation */</span></td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">    htsData.useFourierMag = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use Fourier magnitudes for pulse generation */</span></td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">    htsData.useGV = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use global variance in parameter generation */</span></td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">    htsData.useGmmGV = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* use global variance as a Gaussian Mixture Model */</span></td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">    htsData.useUnitDurationContinuousFeature = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* for using external duration, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN283">283</td><td class="line">    htsData.useUnitLogF0ContinuousFeature = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;    <span class='comment'>/* for using external f0, so it will not be generated from HMMs*/</span></td></tr>
<tr><td class="num" id="LN284">284</td><td class="line">    </td></tr>
<tr><td class="num" id="LN285">285</td><td class="line">    <span class='comment'>/** variables for controling generation of speech in the vocoder</span>       </td></tr>
<tr><td class="num" id="LN286">286</td><td class="line">     <span class='comment'>* these variables have default values but can be fixed and read from the</span></td></tr>
<tr><td class="num" id="LN287">287</td><td class="line">     <span class='comment'>* audio effects component. [Default][min--max]   */</span></td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">    htsData.F0Std   = 1.0;   <span class='comment'>/* variable for f0 control, multiply f0  [1.0][0.0--5.0]   */</span></td></tr>
<tr><td class="num" id="LN289">289</td><td class="line">    htsData.F0Mean  = 0.0;   <span class='comment'>/* variable for f0 control, add f0 [0.0][0.0--100.0] */</span></td></tr>
<tr><td class="num" id="LN290">290</td><td class="line">    htsData.length  = 0.0;   <span class='comment'>/* total number of frame for generated speech */</span></td></tr>
<tr><td class="num" id="LN291">291</td><td class="line">            <span class='comment'>/* length of generated speech (in seconds)   [N/A][0.0--30.0]  */</span></td></tr>
<tr><td class="num" id="LN292">292</td><td class="line">    htsData.durationScale = 1.0; <span class='comment'>/* less than 1.0 is faster and more than 1.0 is slower, min=0.1 max=3.0 */</span></td></tr>
<tr><td class="num" id="LN293">293</td><td class="line"> </td></tr>
<tr><td class="num" id="LN294">294</td><td class="line">    LISP filters = siod_get_lval(<span class='string_literal'>"me_mix_filters"</span>,</td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">                                 <span class='string_literal'>"mlsa: me_mix_filters not set"</span>);</td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">    LISP f;</td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">    <span class='keyword'>int</span> fl;</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">    htsData.NumFilters = 5;</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">    <span class='keyword'>for</span> (fl=0,f=filters; f; fl++)</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line">        f=cdr(f);</td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">    htsData.OrderFilters = fl/htsData.NumFilters;</td></tr>
<tr><td class="num" id="LN302">302</td><td class="line">    htsData.MixFilters = <span class='macro'>walloc(<span class='keyword'>double</span> *,htsData.NumFilters)<span class='expansion'>((double * *)safe_walloc(sizeof(double *)*(htsData.NumFilters<br>)))</span></span>;</td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">    <span class='keyword'>for</span> (i=0; i &lt; htsData.NumFilters; i++)</td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">    {</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">        htsData.MixFilters[i] = <span class='macro'>walloc(<span class='keyword'>double</span>,htsData.OrderFilters)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(htsData.OrderFilters))<br>)</span></span>;</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">        <span class='keyword'>for</span> (j=0; j&lt;htsData.OrderFilters; j++)</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">        {</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line">            htsData.MixFilters[i][j] = <span class='macro'>FLONM(car(filters))<span class='expansion'>((*car(filters)).storage_as.flonum.data)</span></span>;</td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">            filters = cdr(filters);</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line"> </td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">    wave = <span class='keyword'>new</span> EST_Wave(0,1,sr);</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line"> </td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">    <span class='keyword'>if</span> (mcep-&gt;num_frames() &gt; 0)</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">    <span class='comment'>/* mcep_order and number of deltas */</span></td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">        htsMLSAVocoder(f0v,mcep,str,mag,voiced,&amp;htsData,wave);</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">    <span class='keyword'>delete</span> f0v;</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">    <span class='keyword'>delete</span> mcep;</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">    <span class='keyword'>delete</span> str;</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">    <span class='keyword'>delete</span> mag;</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">    <span class='keyword'>delete</span> voiced;</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line"> </td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">    <span class='keyword'>return</span> siod(wave);</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">}</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">    </td></tr>
<tr><td class="num" id="LN328">328</td><td class="line"><span class='comment'>/** The initialisation of VocoderSetup should be done when there is already</span> </td></tr>
<tr><td class="num" id="LN329">329</td><td class="line"> <span class='comment'>* information about the number of feature vectors to be processed,</span></td></tr>
<tr><td class="num" id="LN330">330</td><td class="line"> <span class='comment'>* size of the mcep vector file, etc. */</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line"><span class='keyword'>void</span> initVocoder(<span class='keyword'>int</span> mcep_order, <span class='keyword'>int</span> mcep_vsize, HTSData *htsData) </td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">{</td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">    <span class='keyword'>int</span> vector_size;</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">    <span class='keyword'>double</span> xrand;</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">        </td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">    stage = htsData-&gt;stage;</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">    <span class='keyword'>if</span>(stage != 0)</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">        xgamma = -1.0 / stage;</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">        xgamma = 0.0;</td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">    use_log_gain = htsData-&gt;LogGain;</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">        </td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">    fprd  = htsData-&gt;fperiod;</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">    rate  = htsData-&gt;rate;</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">    iprd  = IPERIOD;</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">    gauss = GAUSS;</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line"> </td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">    <span class='comment'>/* XXX */</span></td></tr>
<tr><td class="num" id="LN349">349</td><td class="line">    xrand = <span class="mrange">rand()</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:5ex">Value stored to 'xrand' is never read</div></td></tr>
<tr><td class="num" id="LN350">350</td><td class="line"> </td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">    <span class='keyword'>if</span>(stage == 0 ){  <span class='comment'>/* for MCP */</span></td></tr>
<tr><td class="num" id="LN352">352</td><td class="line">            </td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">        <span class='comment'>/* mcep_order=74 and pd=PADEORDER=5 (if no HTS_EMBEDDED is used) */</span></td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">        vector_size = (mcep_vsize * ( 3 + PADEORDER) + 5 * PADEORDER + 6) - (3 * (mcep_order+1));</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">        CINC_length = CC_length = C_length = mcep_order+1;</td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">        D1_length = vector_size;</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">        C    = <span class='macro'>walloc(<span class='keyword'>double</span>,C_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(C_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line">        CC   = <span class='macro'>walloc(<span class='keyword'>double</span>,CC_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(CC_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">        CINC = <span class='macro'>walloc(<span class='keyword'>double</span>,CINC_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(CINC_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">        D1   = <span class='macro'>walloc(<span class='keyword'>double</span>,D1_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(D1_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">                    </td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">        vector_size=21;</td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">        pade = <span class='macro'>walloc(<span class='keyword'>double</span>,vector_size)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(vector_size)))</span></span>;</td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">        <span class='comment'>/* ppade is a copy of pade in mlsadf() function : ppade = &amp;( pade[pd*(pd+1)/2] ); */</span></td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">        ppade = PADEORDER*(PADEORDER+1)/2;  <span class='comment'>/* offset for vector pade */</span></td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">        pade[0] = 1.0;</td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">        pade[1] = 1.0; </td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">        pade[2] = 0.0;</td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">        pade[3] = 1.0; </td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">        pade[4] = 0.0;       </td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">        pade[5] = 0.0;</td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">        pade[6] = 1.0; </td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">        pade[7] = 0.0;       </td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">        pade[8] = 0.0;        </td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">        pade[9] = 0.0;</td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">        pade[10] = 1.0;</td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">        pade[11] = 0.4999273; </td></tr>
<tr><td class="num" id="LN378">378</td><td class="line">        pade[12] = 0.1067005; </td></tr>
<tr><td class="num" id="LN379">379</td><td class="line">        pade[13] = 0.01170221; </td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">        pade[14] = 0.0005656279;</td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">        pade[15] = 1.0; </td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">        pade[16] = 0.4999391; </td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">        pade[17] = 0.1107098; </td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">        pade[18] = 0.01369984; </td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">        pade[19] = 0.0009564853;</td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">        pade[20] = 0.00003041721;</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">        </td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">        pt1 = PADEORDER+1;</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">        pt2 = ( 2 * (PADEORDER+1)) + (PADEORDER * (mcep_order+2));</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">        pt3 = <span class='keyword'>new</span> <span class='keyword'>int</span>[PADEORDER+1];</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">        <span class='keyword'>for</span>(<span class='keyword'>int</span> i=PADEORDER; i&gt;=1; i--)</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">            pt3[i] = ( 2 * (PADEORDER+1)) + ((i-1)*(mcep_order+2));</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">          </td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">    } <span class='keyword'>else</span> { <span class='comment'>/* for LSP */</span></td></tr>
<tr><td class="num" id="LN395">395</td><td class="line">        vector_size = ((mcep_vsize+1) * (stage+3)) - ( 3 * (mcep_order+1));</td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">        CINC_length = CC_length = C_length = mcep_order+1;</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">        D1_length = vector_size;</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">        C    = <span class='macro'>walloc(<span class='keyword'>double</span>,C_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(C_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN399">399</td><td class="line">        CC   = <span class='macro'>walloc(<span class='keyword'>double</span>,CC_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(CC_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN400">400</td><td class="line">        CINC = <span class='macro'>walloc(<span class='keyword'>double</span>,CINC_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(CINC_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">        D1   = <span class='macro'>walloc(<span class='keyword'>double</span>,D1_length)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(D1_length)))</span></span>;</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">        </td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">    <span class='comment'>/* excitation initialisation */</span></td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">    p1 = -1;</td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">    pc = 0.0;  </td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">    </td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">} <span class='comment'>/* method initVocoder */</span></td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    </td></tr>
<tr><td class="num" id="LN410">410</td><td class="line"> </td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">    </td></tr>
<tr><td class="num" id="LN412">412</td><td class="line"><span class='comment'>/**</span> </td></tr>
<tr><td class="num" id="LN413">413</td><td class="line"> <span class='comment'>* HTS_MLSA_Vocoder: Synthesis of speech out of mel-cepstral coefficients.</span> </td></tr>
<tr><td class="num" id="LN414">414</td><td class="line"> <span class='comment'>* This procedure uses the parameters generated in pdf2par stored in:</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line"> <span class='comment'>*   PStream mceppst: Mel-cepstral coefficients</span></td></tr>
<tr><td class="num" id="LN416">416</td><td class="line"> <span class='comment'>*   PStream strpst : Filter bank stregths for mixed excitation</span></td></tr>
<tr><td class="num" id="LN417">417</td><td class="line"> <span class='comment'>*   PStream magpst : Fourier magnitudes ( OJO!! this is not used yet)</span></td></tr>
<tr><td class="num" id="LN418">418</td><td class="line"> <span class='comment'>*   PStream lf0pst : Log F0</span>  </td></tr>
<tr><td class="num" id="LN419">419</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN420">420</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">AudioInputStream htsMLSAVocoder(HTSParameterGeneration pdf2par, HMMData htsData) </td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">{</td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">    <span class='keyword'>float</span> sampleRate = 16000.0F;  <span class='comment'>//8000,11025,16000,22050,44100</span></td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">    <span class='keyword'>int</span> sampleSizeInBits = 16;  <span class='comment'>//8,16</span></td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">    <span class='keyword'>int</span> channels = 1;     <span class='comment'>//1,2</span></td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> <span class='keyword'>signed</span> = <span class='keyword'><span class='macro'>true<span class='expansion'>1</span></span></span>;    <span class='comment'>//true,false</span></td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> bigEndian = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;  <span class='comment'>//true,false</span></td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">    AudioFormat af = <span class='keyword'>new</span> AudioFormat(</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">                                     sampleRate,</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">                                     sampleSizeInBits,</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">                                     channels,</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">                                     <span class='keyword'>signed</span>,</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">                                     bigEndian);</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">    <span class='keyword'>double</span> [] audio_double = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">        </td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">    audio_double = htsMLSAVocoder(pdf2par.getlf0Pst(), pdf2par.getMcepPst(), pdf2par.getStrPst(), pdf2par.getMagPst(),</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">                                  pdf2par.getVoicedArray(), htsData);</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">        </td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">    <span class='keyword'>long</span> lengthInSamples = (audio_double.length * 2 ) / (sampleSizeInBits/8);</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">    logger.info(<span class='string_literal'>"length in samples="</span> + lengthInSamples );</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">        </td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">    <span class='comment'>/* Normalise the signal before return, this will normalise between 1 and -1 */</span></td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">    <span class='keyword'>double</span> MaxSample = MathUtils.getAbsMax(audio_double);</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">    <span class='keyword'>for</span> (<span class='keyword'>int</span> i=0; i&lt;audio_double.length; i++)        </td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">        audio_double[i] = 0.3 * ( audio_double[i] / MaxSample );</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">                </td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">    DDSAudioInputStream oais = <span class='keyword'>new</span> DDSAudioInputStream(<span class='keyword'>new</span> BufferedDoubleDataSource(audio_double), af);</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">    <span class='keyword'>return</span> oais;</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">        </td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">        </td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">} <span class='comment'>/* method htsMLSAVocoder() */</span></td></tr>
<tr><td class="num" id="LN452">452</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN453">453</td><td class="line"> </td></tr>
<tr><td class="num" id="LN454">454</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mlsafir(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>double</span> aa, <span class='keyword'>double</span> *d, <span class='keyword'>int</span> _pt3 )</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">{</td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">    <span class='keyword'>double</span> y = 0.0;</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN458">458</td><td class="line"> </td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">    d[_pt3+0] = x;</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">    d[_pt3+1] = aa * d[_pt3+0] + ( a * d[_pt3+1] );</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line"> </td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">    <span class='keyword'>for</span>(i=2; i&lt;=m; i++){</td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">        d[_pt3+i] +=  a * ( d[_pt3+i+1] - d[_pt3+i-1]);</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">      </td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">    <span class='keyword'>for</span>(i=2; i&lt;=m; i++){ </td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">        y += d[_pt3+i] * b[i];</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">       </td></tr>
<tr><td class="num" id="LN470">470</td><td class="line">    <span class='keyword'>for</span>(i=m+1; i&gt;1; i--){</td></tr>
<tr><td class="num" id="LN471">471</td><td class="line">        d[_pt3+i] = d[_pt3+i-1];  </td></tr>
<tr><td class="num" id="LN472">472</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">       </td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">    <span class='keyword'>return</span>(y);</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line">}</td></tr>
<tr><td class="num" id="LN476">476</td><td class="line"> </td></tr>
<tr><td class="num" id="LN477">477</td><td class="line"><span class='comment'>/** mlsdaf1:  sub functions for MLSA filter */</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mlsadf1(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>double</span> aa, <span class='keyword'>double</span> *d) </td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">{</td></tr>
<tr><td class="num" id="LN480">480</td><td class="line">    <span class='keyword'>double</span> v;</td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">    <span class='keyword'>double</span> out = 0.0;</td></tr>
<tr><td class="num" id="LN482">482</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN483">483</td><td class="line">    <span class='comment'>//pt1 --&gt; pt = &amp;d1[pd+1]  </span></td></tr>
<tr><td class="num" id="LN484">484</td><td class="line">       </td></tr>
<tr><td class="num" id="LN485">485</td><td class="line">    <span class='keyword'>for</span>(i=PADEORDER; i&gt;=1; i--) {</td></tr>
<tr><td class="num" id="LN486">486</td><td class="line">        d[i] = aa * d[pt1+i-1] + a * d[i];  </td></tr>
<tr><td class="num" id="LN487">487</td><td class="line">        d[pt1+i] = d[i] * b[1];</td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">        v = d[pt1+i] * pade[ppade+i];</td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">      </td></tr>
<tr><td class="num" id="LN490">490</td><td class="line">        <span class='comment'>//x += (1 &amp; i) ? v : -v;</span></td></tr>
<tr><td class="num" id="LN491">491</td><td class="line">        <span class='keyword'>if</span>(i == 1 || i == 3 || i == 5)</td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">            x += v;</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">        <span class='keyword'>else</span> </td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">            x += -v;</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line">        out += v;</td></tr>
<tr><td class="num" id="LN496">496</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN497">497</td><td class="line">    d[pt1+0] = x;</td></tr>
<tr><td class="num" id="LN498">498</td><td class="line">    out += x;</td></tr>
<tr><td class="num" id="LN499">499</td><td class="line"> </td></tr>
<tr><td class="num" id="LN500">500</td><td class="line">    <span class='keyword'>return</span>(out);</td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">      </td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">}</td></tr>
<tr><td class="num" id="LN503">503</td><td class="line"> </td></tr>
<tr><td class="num" id="LN504">504</td><td class="line"><span class='comment'>/** mlsdaf2: sub functions for MLSA filter */</span></td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mlsadf2(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>double</span> aa, <span class='keyword'>double</span> *d) </td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">{</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line">    <span class='keyword'>double</span> v;</td></tr>
<tr><td class="num" id="LN508">508</td><td class="line">    <span class='keyword'>double</span> out = 0.0;</td></tr>
<tr><td class="num" id="LN509">509</td><td class="line">    <span class='keyword'>int</span> i; </td></tr>
<tr><td class="num" id="LN510">510</td><td class="line">    <span class='comment'>// pt2 --&gt; pt = &amp;d1[pd * (m+2)] </span></td></tr>
<tr><td class="num" id="LN511">511</td><td class="line">    <span class='comment'>// pt3 --&gt; pt = &amp;d1[ 2*(pd+1) ] </span></td></tr>
<tr><td class="num" id="LN512">512</td><td class="line">      </td></tr>
<tr><td class="num" id="LN513">513</td><td class="line">    <span class='keyword'>for</span>(i=PADEORDER; i&gt;=1; i--) {   </td></tr>
<tr><td class="num" id="LN514">514</td><td class="line">        d[pt2+i] = mlsafir(d[(pt2+i)-1], b, m, a, aa, d, pt3[i]);</td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">        v = d[pt2+i] * pade[ppade+i];</td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">          </td></tr>
<tr><td class="num" id="LN517">517</td><td class="line">        <span class='keyword'>if</span>(i == 1 || i == 3 || i == 5)</td></tr>
<tr><td class="num" id="LN518">518</td><td class="line">            x += v;</td></tr>
<tr><td class="num" id="LN519">519</td><td class="line">        <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN520">520</td><td class="line">            x += -v;</td></tr>
<tr><td class="num" id="LN521">521</td><td class="line">        out += v;</td></tr>
<tr><td class="num" id="LN522">522</td><td class="line">        </td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">    d[pt2+0] = x;</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">    out += x;</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">       </td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">    <span class='keyword'>return</span> out;     </td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">}</td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">    </td></tr>
<tr><td class="num" id="LN530">530</td><td class="line"><span class='comment'>/** mlsadf: HTS Mel Log Spectrum Approximation filter */</span></td></tr>
<tr><td class="num" id="LN531">531</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mlsadf(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>double</span> aa, <span class='keyword'>double</span> *d) </td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">{</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">        </td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">    x = mlsadf1(x, b, m,   a, aa, d);  </td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">    x = mlsadf2(x, b, m-1, a, aa, d);</td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">       </td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">    <span class='keyword'>return</span> x; </td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">}</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">    </td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">    </td></tr>
<tr><td class="num" id="LN541">541</td><td class="line"><span class='comment'>/** uniform_rand: generate uniformly distributed random numbers 1 or -1 */</span></td></tr>
<tr><td class="num" id="LN542">542</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> uniformRand() </td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">{  </td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">    <span class='keyword'>double</span> x;</td></tr>
<tr><td class="num" id="LN545">545</td><td class="line"> </td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">    x = rand(); <span class='comment'>/* double uniformly distributed between 0.0 &lt;= Math.random() &lt; 1.0.*/</span></td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">    <span class='keyword'>if</span>(x &gt;= <span class='macro'>RAND_MAX<span class='expansion'>2147483647</span></span>/2.0)</td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">        <span class='keyword'>return</span> 1.0;</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">        <span class='keyword'>return</span> -1.0;</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">}</td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">       </td></tr>
<tr><td class="num" id="LN553">553</td><td class="line"><span class='comment'>/** mc2b: transform mel-cepstrum to MLSA digital filter coefficients */</span></td></tr>
<tr><td class="num" id="LN554">554</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> mc2b(<span class='keyword'>double</span> *mc, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a ) </td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">{</td></tr>
<tr><td class="num" id="LN556">556</td><td class="line"> </td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">    b[m] = mc[m];</td></tr>
<tr><td class="num" id="LN558">558</td><td class="line">    <span class='keyword'>for</span>(m--; m&gt;=0; m--) {</td></tr>
<tr><td class="num" id="LN559">559</td><td class="line">        b[m] = mc[m] - a * b[m+1];  </td></tr>
<tr><td class="num" id="LN560">560</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">}</td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">    </td></tr>
<tr><td class="num" id="LN563">563</td><td class="line"><span class='comment'>/** b2mc: transform MLSA digital filter coefficients to mel-cepstrum */</span></td></tr>
<tr><td class="num" id="LN564">564</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> b2mc(<span class='keyword'>double</span> *b, <span class='keyword'>double</span> *mc, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a)</td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">{</td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">    <span class='keyword'>double</span> d, o;</td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">    d = mc[m] = b[m];</td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">    <span class='keyword'>for</span>(i=m--; i&gt;=0; i--) {</td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">        o = b[i] + (a * d);</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">        d = b[i];</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line">        mc[i] = o;</td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">}</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">    </td></tr>
<tr><td class="num" id="LN576">576</td><td class="line"> </td></tr>
<tr><td class="num" id="LN577">577</td><td class="line"><span class='comment'>/** freqt: frequency transformation */</span></td></tr>
<tr><td class="num" id="LN578">578</td><td class="line"><span class='comment'>//private void freqt(double c1[], int m1, int cepIndex, int m2, double a){</span></td></tr>
<tr><td class="num" id="LN579">579</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> freqt(<span class='keyword'>double</span> *c1, <span class='keyword'>int</span> m1, <span class='keyword'>double</span> *c2, <span class='keyword'>int</span> m2, <span class='keyword'>double</span> a)</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">{</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">    <span class='keyword'>double</span> *freqt_buff=<span class='macro'>NULL<span class='expansion'>__null</span></span>;        <span class='comment'>/* used in freqt */</span></td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">    <span class='keyword'>int</span>    freqt_size=0;          <span class='comment'>/* buffer size for freqt */</span></td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">    <span class='keyword'>int</span> i, j;</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">    <span class='keyword'>double</span> b = 1 - a * a;</td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">    <span class='keyword'>int</span> g; <span class='comment'>/* offset of freqt_buff */</span></td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">       </td></tr>
<tr><td class="num" id="LN587">587</td><td class="line">    <span class='keyword'>if</span>(m2 &gt; freqt_size) {</td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">        freqt_buff = <span class='macro'>walloc(<span class='keyword'>double</span>,m2 + m2 + 2)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(m2 + m2 + 2)))</span></span>;</td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">        freqt_size = m2;  </td></tr>
<tr><td class="num" id="LN590">590</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">    g = freqt_size +1;</td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">     </td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">    <span class='keyword'>for</span>(i = 0; i &lt; m2+1; i++)</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">        freqt_buff[g+i] = 0.0;</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">     </td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">    <span class='keyword'>for</span>(i = -m1; i &lt;= 0; i++){</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">        <span class='keyword'>if</span>(0 &lt;= m2 )  </td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">            freqt_buff[g+0] = c1[-i] + a * (freqt_buff[0] = freqt_buff[g+0]);</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">        <span class='keyword'>if</span>(1 &lt;= m2)</td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">            freqt_buff[g+1] = b * freqt_buff[0] + a * (freqt_buff[1] = freqt_buff[g+1]);</td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">           </td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">        <span class='keyword'>for</span>(j=2; j&lt;=m2; j++)</td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">            freqt_buff[g+j] = freqt_buff[j-1] + a * ( (freqt_buff[j] = freqt_buff[g+j]) - freqt_buff[g+j-1]);</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">           </td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">     </td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">    <span class='comment'>/* move memory */</span></td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt;m2+1; i++)</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">        c2[i] = freqt_buff[g+i];</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line"> </td></tr>
<tr><td class="num" id="LN611">611</td><td class="line">    <span class='keyword'>if</span> (freqt_buff)</td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">        wfree(freqt_buff);</td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">       </td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">}</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">   </td></tr>
<tr><td class="num" id="LN616">616</td><td class="line"><span class='comment'>/** c2ir: The minimum phase impulse response is evaluated from the minimum phase cepstrum */</span></td></tr>
<tr><td class="num" id="LN617">617</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> c2ir(<span class='keyword'>double</span> *c, <span class='keyword'>int</span> nc, <span class='keyword'>double</span> *hh, <span class='keyword'>int</span> leng )</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">{</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">    <span class='keyword'>int</span> n, k, upl;</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">    <span class='keyword'>double</span> d;</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line"> </td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">    hh[0] = exp(c[0]);</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line">    <span class='keyword'>for</span>(n = 1; n &lt; leng; n++) {</td></tr>
<tr><td class="num" id="LN624">624</td><td class="line">        d = 0;</td></tr>
<tr><td class="num" id="LN625">625</td><td class="line">        upl = (n &gt;= nc) ? nc - 1 : n;</td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">        <span class='keyword'>for</span>(k = 1; k &lt;= upl; k++ )</td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">            d += k * c[k] * hh[n - k];</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">        hh[n] = d / n;</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">}</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">   </td></tr>
<tr><td class="num" id="LN632">632</td><td class="line"><span class='comment'>/** b2en: functions for postfiltering */</span> </td></tr>
<tr><td class="num" id="LN633">633</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> b2en(<span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a)</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line">{</td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">    <span class='keyword'>double</span> *spectrum2en_buff=<span class='macro'>NULL<span class='expansion'>__null</span></span>;  <span class='comment'>/* used in spectrum2en */</span></td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">    <span class='keyword'>int</span>    spectrum2en_size=0;    <span class='comment'>/* buffer size for spectrum2en */</span></td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">    <span class='keyword'>double</span> en = 0.0;</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">    <span class='keyword'>double</span> *cep, *ir; </td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">      </td></tr>
<tr><td class="num" id="LN641">641</td><td class="line">    <span class='keyword'>if</span>(spectrum2en_size &lt; m) {</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">        spectrum2en_buff = <span class='macro'>walloc(<span class='keyword'>double</span>,(m+1) + 2 * IRLENG)<span class='expansion'>((double *)safe_walloc(sizeof(double)*((m+1) + 2 * IRLENG)))</span></span>;</td></tr>
<tr><td class="num" id="LN643">643</td><td class="line">        spectrum2en_size = m;</td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line">    cep = <span class='macro'>walloc(<span class='keyword'>double</span>,(m+1) + 2 * IRLENG)<span class='expansion'>((double *)safe_walloc(sizeof(double)*((m+1) + 2 * IRLENG)))</span></span>; <span class='comment'>/* CHECK! these sizes!!! */</span></td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">    ir = <span class='macro'>walloc(<span class='keyword'>double</span>,(m+1) + 2 * IRLENG)<span class='expansion'>((double *)safe_walloc(sizeof(double)*((m+1) + 2 * IRLENG)))</span></span>;</td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">      </td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">    b2mc(b, spectrum2en_buff, m, a);</td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">    <span class='comment'>/* freqt(vs-&gt;mc, m, vs-&gt;cep, vs-&gt;irleng - 1, -a);*/</span></td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">    freqt(spectrum2en_buff, m, cep, IRLENG-1, -a);</td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">    <span class='comment'>/* HTS_c2ir(vs-&gt;cep, vs-&gt;irleng, vs-&gt;ir, vs-&gt;irleng); */</span></td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">    c2ir(cep, IRLENG, ir, IRLENG);</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">    en = 0.0;</td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">      </td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">    <span class='keyword'>for</span>(i = 0; i &lt; IRLENG; i++)</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">        en += ir[i] * ir[i];</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line"> </td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">    <span class='keyword'>if</span> (spectrum2en_buff)</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line">        wfree(spectrum2en_buff);</td></tr>
<tr><td class="num" id="LN660">660</td><td class="line">    wfree(cep);</td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">    wfree(ir);</td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">      </td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">    <span class='keyword'>return</span>(en);  </td></tr>
<tr><td class="num" id="LN664">664</td><td class="line">}  </td></tr>
<tr><td class="num" id="LN665">665</td><td class="line">    </td></tr>
<tr><td class="num" id="LN666">666</td><td class="line"><span class='comment'>/** ignorm: inverse gain normalization */</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> ignorm(<span class='keyword'>double</span> *c1, <span class='keyword'>double</span> *c2, <span class='keyword'>int</span> m, <span class='keyword'>double</span> ng)</td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">{</td></tr>
<tr><td class="num" id="LN669">669</td><td class="line">    <span class='keyword'>double</span> k;</td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">    <span class='keyword'>if</span>(ng != 0.0 ) {</td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">        k = pow(c1[0], ng);</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">        <span class='keyword'>for</span>(i=m; i&gt;=1; i--)</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">            c2[i] = k * c1[i];</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">        c2[0] = (k - 1.0) / ng;</td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">        <span class='comment'>/* movem */</span>  </td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">        <span class='keyword'>for</span>(i=1; i&lt;m; i++)  </td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">            c2[i] = c1[i];</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">        c2[0] = log(c1[0]);   </td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">}</td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">   </td></tr>
<tr><td class="num" id="LN684">684</td><td class="line"><span class='comment'>/** ignorm: gain normalization */</span></td></tr>
<tr><td class="num" id="LN685">685</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> gnorm(<span class='keyword'>double</span> *c1, <span class='keyword'>double</span> *c2, <span class='keyword'>int</span> m, <span class='keyword'>double</span> g)</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">{</td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">    <span class='keyword'>double</span> k;</td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">    <span class='keyword'>if</span>(g != 0.0) {</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">        k = 1.0 + g * c1[0];</td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">        <span class='keyword'>for</span>(; m&gt;=1; m--)</td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">            c2[m] = c1[m] / k;</td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">        c2[0] = pow(k, 1.0 / g);</td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">        <span class='comment'>/* movem */</span>  </td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">        <span class='keyword'>for</span>(i=1; i&lt;=m; i++)  </td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">            c2[i] = c1[i];</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">        c2[0] = exp(c1[0]);</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">       </td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">}</td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">   </td></tr>
<tr><td class="num" id="LN703">703</td><td class="line"><span class='comment'>/** lsp2lpc: transform LSP to LPC. lsp[1..m] --&gt; a=lpc[0..m]  a[0]=1.0 */</span></td></tr>
<tr><td class="num" id="LN704">704</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> lsp2lpc(<span class='keyword'>double</span> *lsp, <span class='keyword'>double</span> *a, <span class='keyword'>int</span> m)</td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">{</td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">    <span class='keyword'>double</span> *lsp2lpc_buff=<span class='macro'>NULL<span class='expansion'>__null</span></span>;      <span class='comment'>/* used in lsp2lpc */</span></td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">    <span class='keyword'>int</span>    lsp2lpc_size=0;        <span class='comment'>/* buffer size of lsp2lpc */</span></td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">    <span class='keyword'>int</span> i, k, mh1, mh2, flag_odd;</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">    <span class='keyword'>double</span> xx, xf, xff;</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">    <span class='keyword'>int</span> p, q;                    <span class='comment'>/* offsets of lsp2lpc_buff */</span></td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">    <span class='keyword'>int</span> a0, a1, a2, b0, b1, b2;  <span class='comment'>/* offsets of lsp2lpc_buff */</span></td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">      </td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">    flag_odd = 0;</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">    <span class='keyword'>if</span>(m % 2 == 0)</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">        mh1 = mh2 = m / 2;</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line">    <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">        mh1 = (m+1) / 2;</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">        mh2 = (m-1) / 2;</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">        flag_odd = 1;</td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">      </td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">    <span class='keyword'>if</span>(m &gt; lsp2lpc_size){</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">        lsp2lpc_buff = <span class='macro'>walloc(<span class='keyword'>double</span>,5 * m + 6)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(5 * m + 6)))</span></span>;</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">        lsp2lpc_size = m;</td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">      </td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">    <span class='comment'>/* offsets of lsp2lpcbuff */</span></td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">    p = m;</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">    q = p + mh1;</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">    a0 = q + mh2;</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">    a1 = a0 + (mh1 +1);</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">    a2 = a1 + (mh1 +1);</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">    b0 = a2 + (mh1 +1);</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line">    b1 = b0 + (mh2 +1);</td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">    b2 = b1 + (mh2 +1);</td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">      </td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">    <span class='comment'>/* move lsp -&gt; lsp2lpc_buff */</span></td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">        lsp2lpc_buff[i] = lsp[i+1];</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line">      </td></tr>
<tr><td class="num" id="LN741">741</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh1 + 1; i++)</td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">        lsp2lpc_buff[a0 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN743">743</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh1 + 1; i++)</td></tr>
<tr><td class="num" id="LN744">744</td><td class="line">        lsp2lpc_buff[a1 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN745">745</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh1 + 1; i++)</td></tr>
<tr><td class="num" id="LN746">746</td><td class="line">        lsp2lpc_buff[a2 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN747">747</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh2 + 1; i++)</td></tr>
<tr><td class="num" id="LN748">748</td><td class="line">        lsp2lpc_buff[b0 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN749">749</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh2 + 1; i++)</td></tr>
<tr><td class="num" id="LN750">750</td><td class="line">        lsp2lpc_buff[b1 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN751">751</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; mh2 + 1; i++)</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line">        lsp2lpc_buff[b2 + i] = 0.0;</td></tr>
<tr><td class="num" id="LN753">753</td><td class="line"> </td></tr>
<tr><td class="num" id="LN754">754</td><td class="line">    <span class='comment'>/* lsp filter parameters */</span></td></tr>
<tr><td class="num" id="LN755">755</td><td class="line">    <span class='keyword'>for</span> (i = k = 0; i &lt; mh1; i++, k += 2)</td></tr>
<tr><td class="num" id="LN756">756</td><td class="line">        lsp2lpc_buff[p + i] = -2.0 * cos(lsp2lpc_buff[k]);</td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">    <span class='keyword'>for</span> (i = k = 0; i &lt; mh2; i++, k += 2)</td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">        lsp2lpc_buff[q + i] = -2.0 * cos(lsp2lpc_buff[k + 1]);</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">      </td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">    <span class='comment'>/* impulse response of analysis filter */</span></td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">    xx = 1.0;</td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">    xf = xff = 0.0;</td></tr>
<tr><td class="num" id="LN763">763</td><td class="line">      </td></tr>
<tr><td class="num" id="LN764">764</td><td class="line">    <span class='keyword'>for</span> (k = 0; k &lt;= m; k++) {</td></tr>
<tr><td class="num" id="LN765">765</td><td class="line">        <span class='keyword'>if</span> (flag_odd == 1) {</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line">            lsp2lpc_buff[a0 + 0] = xx;</td></tr>
<tr><td class="num" id="LN767">767</td><td class="line">            lsp2lpc_buff[b0 + 0] = xx - xff;</td></tr>
<tr><td class="num" id="LN768">768</td><td class="line">            xff = xf;</td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">            xf = xx;</td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN771">771</td><td class="line">            lsp2lpc_buff[a0 + 0] = xx + xf;</td></tr>
<tr><td class="num" id="LN772">772</td><td class="line">            lsp2lpc_buff[b0 + 0] = xx - xf;</td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">            xf = xx;</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN775">775</td><td class="line"> </td></tr>
<tr><td class="num" id="LN776">776</td><td class="line">        <span class='keyword'>for</span> (i = 0; i &lt; mh1; i++) {</td></tr>
<tr><td class="num" id="LN777">777</td><td class="line">            lsp2lpc_buff[a0 + i + 1] = lsp2lpc_buff[a0 + i] + lsp2lpc_buff[p + i] * lsp2lpc_buff[a1 + i] + lsp2lpc_buff[a2 + i];</td></tr>
<tr><td class="num" id="LN778">778</td><td class="line">            lsp2lpc_buff[a2 + i] = lsp2lpc_buff[a1 + i];</td></tr>
<tr><td class="num" id="LN779">779</td><td class="line">            lsp2lpc_buff[a1 + i] = lsp2lpc_buff[a0 + i];</td></tr>
<tr><td class="num" id="LN780">780</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN781">781</td><td class="line"> </td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">        <span class='keyword'>for</span> (i = 0; i &lt; mh2; i++) {</td></tr>
<tr><td class="num" id="LN783">783</td><td class="line">            lsp2lpc_buff[b0 + i + 1] = lsp2lpc_buff[b0 + i] + lsp2lpc_buff[q + i] * lsp2lpc_buff[b1 + i] + lsp2lpc_buff[b2 + i];</td></tr>
<tr><td class="num" id="LN784">784</td><td class="line">            lsp2lpc_buff[b2 + i] = lsp2lpc_buff[b1 + i];</td></tr>
<tr><td class="num" id="LN785">785</td><td class="line">            lsp2lpc_buff[b1 + i] = lsp2lpc_buff[b0 + i];</td></tr>
<tr><td class="num" id="LN786">786</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN787">787</td><td class="line"> </td></tr>
<tr><td class="num" id="LN788">788</td><td class="line">        <span class='keyword'>if</span> (k != 0)</td></tr>
<tr><td class="num" id="LN789">789</td><td class="line">            a[k - 1] = -0.5 * (lsp2lpc_buff[a0 + mh1] + lsp2lpc_buff[b0 + mh2]);</td></tr>
<tr><td class="num" id="LN790">790</td><td class="line">        xx = 0.0;</td></tr>
<tr><td class="num" id="LN791">791</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN792">792</td><td class="line"> </td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">    <span class='keyword'>for</span> (i = m - 1; i &gt;= 0; i--)</td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">        a[i + 1] = -a[i];</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">    a[0] = 1.0;</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line"> </td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">    <span class='keyword'>if</span> (lsp2lpc_buff)</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">        wfree(lsp2lpc_buff);</td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">}</td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">    </td></tr>
<tr><td class="num" id="LN801">801</td><td class="line"><span class='comment'>/** gc2gc: generalized cepstral transformation */</span></td></tr>
<tr><td class="num" id="LN802">802</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> gc2gc(<span class='keyword'>double</span> *c1, <span class='keyword'>int</span> m1, <span class='keyword'>double</span> g1, <span class='keyword'>double</span> *c2, <span class='keyword'>int</span> m2, <span class='keyword'>double</span> g2)</td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">{</td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">    <span class='keyword'>double</span> *gc2gc_buff=<span class='macro'>NULL<span class='expansion'>__null</span></span>;        <span class='comment'>/* used in gc2gc */</span></td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">    <span class='keyword'>int</span>    gc2gc_size=0;          <span class='comment'>/* buffer size for gc2gc */</span></td></tr>
<tr><td class="num" id="LN806">806</td><td class="line">    <span class='keyword'>int</span> i, min, k, mk;</td></tr>
<tr><td class="num" id="LN807">807</td><td class="line">    <span class='keyword'>double</span> ss1, ss2, cc;</td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">      </td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">    <span class='keyword'>if</span>( m1 &gt; gc2gc_size ) {</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">        gc2gc_buff = <span class='macro'>walloc(<span class='keyword'>double</span>,m1 + 1)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(m1 + 1)))</span></span>; <span class='comment'>/* check if these buffers should be created all the time */</span></td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">        gc2gc_size = m1;</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">      </td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">    <span class='comment'>/* movem*/</span></td></tr>
<tr><td class="num" id="LN815">815</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt;(m1+1); i++)</td></tr>
<tr><td class="num" id="LN816">816</td><td class="line">        gc2gc_buff[i] = c1[i];</td></tr>
<tr><td class="num" id="LN817">817</td><td class="line">      </td></tr>
<tr><td class="num" id="LN818">818</td><td class="line">    c2[0] = gc2gc_buff[0];</td></tr>
<tr><td class="num" id="LN819">819</td><td class="line">      </td></tr>
<tr><td class="num" id="LN820">820</td><td class="line">    <span class='keyword'>for</span>( i=1; i&lt;=m2; i++){</td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">        ss1 = ss2 = 0.0;</td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">        min = m1 &lt; i ? m1 : i - 1;</td></tr>
<tr><td class="num" id="LN823">823</td><td class="line">        <span class='keyword'>for</span>(k=1; k&lt;=min; k++){</td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">            mk = i - k;</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line">            cc = gc2gc_buff[k] * c2[mk];</td></tr>
<tr><td class="num" id="LN826">826</td><td class="line">            ss2 += k * cc;</td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">            ss1 += mk * cc;</td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">        </td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">        <span class='keyword'>if</span>(i &lt;= m1)</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">            c2[i] = gc2gc_buff[i] + (g2 * ss2 - g1 * ss1) / i;</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">        <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">            c2[i] = (g2 * ss2 - g1 * ss1) / i;   </td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line"> </td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">    <span class='keyword'>if</span> (gc2gc_buff)</td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">        wfree(gc2gc_buff);</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">}</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">    </td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">    <span class='comment'>/** mgc2mgc: frequency and generalized cepstral transformation */</span></td></tr>
<tr><td class="num" id="LN841">841</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> mgc2mgc(<span class='keyword'>double</span> *c1, <span class='keyword'>int</span> m1, <span class='keyword'>double</span> a1, <span class='keyword'>double</span> g1, <span class='keyword'>double</span> *c2, <span class='keyword'>int</span> m2, <span class='keyword'>double</span> a2, <span class='keyword'>double</span> g2)</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">{</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">    <span class='keyword'>double</span> a;</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">      </td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">    <span class='keyword'>if</span>(a1 == a2){</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">        gnorm(c1, c1, m1, g1);</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">        gc2gc(c1, m1, g1, c2, m2, g2);</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">        ignorm(c2, c2, m2, g2);          </td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">        a = (a2 -a1) / (1 - a1 * a2);</td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">        freqt(c1, m1, c2, m2, a);</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">        gnorm(c2, c2, m2, g1);</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">        gc2gc(c2, m2, g1, c2, m2, g2);</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">        ignorm(c2, c2, m2, g2);</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">          </td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">}</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">    </td></tr>
<tr><td class="num" id="LN859">859</td><td class="line"><span class='comment'>/** lsp2mgc: transform LSP to MGC.  lsp=C[0..m]  mgc=C[0..m] */</span></td></tr>
<tr><td class="num" id="LN860">860</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> lsp2mgc(<span class='keyword'>double</span> *lsp, <span class='keyword'>double</span> *mgc, <span class='keyword'>int</span> m, <span class='keyword'>double</span> alpha)</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">{</td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">    <span class='comment'>/* lsp2lpc */</span></td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">    lsp2lpc(lsp, mgc, m);  <span class='comment'>/* lsp starts in 1!  lsp[1..m] --&gt; mgc[0..m] */</span></td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">    <span class='keyword'>if</span>(use_log_gain)</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">        mgc[0] = exp(lsp[0]);</td></tr>
<tr><td class="num" id="LN867">867</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">        mgc[0] = lsp[0];</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">      </td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">    <span class='comment'>/* mgc2mgc*/</span></td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">    <span class='keyword'>if</span>(NORMFLG1)</td></tr>
<tr><td class="num" id="LN872">872</td><td class="line">        ignorm(mgc, mgc, m, xgamma);  </td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span>(MULGFLG1)</td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">        mgc[0] = (1.0 - mgc[0]) * stage; </td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">      </td></tr>
<tr><td class="num" id="LN876">876</td><td class="line">    <span class='keyword'>if</span>(MULGFLG1)</td></tr>
<tr><td class="num" id="LN877">877</td><td class="line">        <span class='keyword'>for</span>(i=m; i&gt;=1; i--) </td></tr>
<tr><td class="num" id="LN878">878</td><td class="line">            mgc[i] *= -stage;    </td></tr>
<tr><td class="num" id="LN879">879</td><td class="line">      </td></tr>
<tr><td class="num" id="LN880">880</td><td class="line">    mgc2mgc(mgc, m, alpha, xgamma, mgc, m, alpha, xgamma);  <span class='comment'>/* input and output is in mgc=C */</span></td></tr>
<tr><td class="num" id="LN881">881</td><td class="line">      </td></tr>
<tr><td class="num" id="LN882">882</td><td class="line">    <span class='keyword'>if</span>(NORMFLG2)</td></tr>
<tr><td class="num" id="LN883">883</td><td class="line">        gnorm(mgc, mgc, m, xgamma);</td></tr>
<tr><td class="num" id="LN884">884</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span>(MULGFLG2)</td></tr>
<tr><td class="num" id="LN885">885</td><td class="line">        mgc[0] = mgc[0] * xgamma + 1.0;</td></tr>
<tr><td class="num" id="LN886">886</td><td class="line">      </td></tr>
<tr><td class="num" id="LN887">887</td><td class="line">    <span class='keyword'>if</span>(MULGFLG2)</td></tr>
<tr><td class="num" id="LN888">888</td><td class="line">        <span class='keyword'>for</span>(i=m; i&gt;=1; i--)</td></tr>
<tr><td class="num" id="LN889">889</td><td class="line">            mgc[i] *= xgamma;</td></tr>
<tr><td class="num" id="LN890">890</td><td class="line">        </td></tr>
<tr><td class="num" id="LN891">891</td><td class="line">}</td></tr>
<tr><td class="num" id="LN892">892</td><td class="line">    </td></tr>
<tr><td class="num" id="LN893">893</td><td class="line"><span class='comment'>/** mglsadf: sub functions for MGLSA filter */</span></td></tr>
<tr><td class="num" id="LN894">894</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mglsadff(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>double</span> *d, <span class='keyword'>int</span> d_offset)</td></tr>
<tr><td class="num" id="LN895">895</td><td class="line">{</td></tr>
<tr><td class="num" id="LN896">896</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN897">897</td><td class="line">    <span class='keyword'>double</span> y;</td></tr>
<tr><td class="num" id="LN898">898</td><td class="line">    y = d[d_offset+0] * b[1];</td></tr>
<tr><td class="num" id="LN899">899</td><td class="line">      </td></tr>
<tr><td class="num" id="LN900">900</td><td class="line">    <span class='keyword'>for</span>(i=1; i&lt;m; i++) {</td></tr>
<tr><td class="num" id="LN901">901</td><td class="line">        d[d_offset+i] += a * (d[d_offset+i+1] -d[d_offset+i-1]);</td></tr>
<tr><td class="num" id="LN902">902</td><td class="line">        y += d[d_offset+i] * b[i+1];</td></tr>
<tr><td class="num" id="LN903">903</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN904">904</td><td class="line">    x -= y;</td></tr>
<tr><td class="num" id="LN905">905</td><td class="line">      </td></tr>
<tr><td class="num" id="LN906">906</td><td class="line">    <span class='keyword'>for</span>(i=m; i&gt;0; i--)</td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">        d[d_offset+i] = d[d_offset+i-1];</td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">    d[d_offset+0] = a * d[d_offset+0] + (1 - a * a) * x;</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">      </td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">    <span class='keyword'>return</span> x;</td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">}</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line"> </td></tr>
<tr><td class="num" id="LN913">913</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> mglsadf(<span class='keyword'>double</span> x, <span class='keyword'>double</span> *b, <span class='keyword'>int</span> m, <span class='keyword'>double</span> a, <span class='keyword'>int</span> n, <span class='keyword'>double</span> *d) </td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">{</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt;n; i++)</td></tr>
<tr><td class="num" id="LN917">917</td><td class="line">        x = mglsadff(x, b, m, a, d, (i*(m+1)));  </td></tr>
<tr><td class="num" id="LN918">918</td><td class="line">              </td></tr>
<tr><td class="num" id="LN919">919</td><td class="line">    <span class='keyword'>return</span> x;</td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">}</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line">   </td></tr>
<tr><td class="num" id="LN922">922</td><td class="line"><span class='comment'>/** posfilter: postfilter for mel-cepstrum. It uses alpha and beta defined in HMMData */</span></td></tr>
<tr><td class="num" id="LN923">923</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> postfilter_mcp(<span class='keyword'>double</span> *mcp, <span class='keyword'>int</span> m, <span class='keyword'>double</span> alpha, <span class='keyword'>double</span> beta) </td></tr>
<tr><td class="num" id="LN924">924</td><td class="line">{</td></tr>
<tr><td class="num" id="LN925">925</td><td class="line">    <span class='keyword'>double</span> *postfilter_buff=<span class='macro'>NULL<span class='expansion'>__null</span></span>;   <span class='comment'>/* used in postfiltering */</span></td></tr>
<tr><td class="num" id="LN926">926</td><td class="line">    <span class='keyword'>int</span> postfilter_size = 0;     <span class='comment'>/* buffer size for postfiltering */</span></td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">        </td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">    <span class='keyword'>double</span> e1, e2;</td></tr>
<tr><td class="num" id="LN929">929</td><td class="line">    <span class='keyword'>int</span> k;</td></tr>
<tr><td class="num" id="LN930">930</td><td class="line">      </td></tr>
<tr><td class="num" id="LN931">931</td><td class="line">    <span class='keyword'>if</span>(beta &gt; 0.0 &amp;&amp; m &gt; 1){</td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">        <span class='keyword'>if</span>(postfilter_size &lt; m){</td></tr>
<tr><td class="num" id="LN933">933</td><td class="line">            postfilter_buff = <span class='macro'>walloc(<span class='keyword'>double</span>,m+1)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(m+1)))</span></span>;</td></tr>
<tr><td class="num" id="LN934">934</td><td class="line">            postfilter_size = m;</td></tr>
<tr><td class="num" id="LN935">935</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN936">936</td><td class="line">        mc2b(mcp, postfilter_buff, m, alpha);</td></tr>
<tr><td class="num" id="LN937">937</td><td class="line">        e1 = b2en(postfilter_buff, m, alpha);</td></tr>
<tr><td class="num" id="LN938">938</td><td class="line">        </td></tr>
<tr><td class="num" id="LN939">939</td><td class="line">        postfilter_buff[1] -= beta * alpha * mcp[2];</td></tr>
<tr><td class="num" id="LN940">940</td><td class="line">        <span class='keyword'>for</span>(k = 2; k &lt; m; k++)</td></tr>
<tr><td class="num" id="LN941">941</td><td class="line">            postfilter_buff[k] *= (1.0 +beta);</td></tr>
<tr><td class="num" id="LN942">942</td><td class="line">        e2 = b2en(postfilter_buff, m, alpha);</td></tr>
<tr><td class="num" id="LN943">943</td><td class="line">        postfilter_buff[0] += log(e1/e2) / 2;</td></tr>
<tr><td class="num" id="LN944">944</td><td class="line">        b2mc(postfilter_buff, mcp, m, alpha);</td></tr>
<tr><td class="num" id="LN945">945</td><td class="line">          </td></tr>
<tr><td class="num" id="LN946">946</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN947">947</td><td class="line"> </td></tr>
<tr><td class="num" id="LN948">948</td><td class="line">    <span class='keyword'>if</span> (postfilter_buff)</td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">        wfree(postfilter_buff);</td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">            </td></tr>
<tr><td class="num" id="LN951">951</td><td class="line">}</td></tr>
<tr><td class="num" id="LN952">952</td><td class="line"> </td></tr>
<tr><td class="num" id="LN953">953</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> modShift(<span class='keyword'>int</span> n, <span class='keyword'>int</span> N)</td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">{</td></tr>
<tr><td class="num" id="LN955">955</td><td class="line">    <span class='keyword'>if</span>( n &lt; 0 )</td></tr>
<tr><td class="num" id="LN956">956</td><td class="line">        <span class='keyword'>while</span>( n &lt; 0 )</td></tr>
<tr><td class="num" id="LN957">957</td><td class="line">            n = n + N;</td></tr>
<tr><td class="num" id="LN958">958</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN959">959</td><td class="line">        <span class='keyword'>while</span>( n &gt;= N )</td></tr>
<tr><td class="num" id="LN960">960</td><td class="line">            n = n - N;</td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">    <span class='keyword'>return</span> n;</td></tr>
<tr><td class="num" id="LN962">962</td><td class="line">}</td></tr>
<tr><td class="num" id="LN963">963</td><td class="line">              </td></tr>
<tr><td class="num" id="LN964">964</td><td class="line"><span class='comment'>/** Generate one pitch period from Fourier magnitudes */</span></td></tr>
<tr><td class="num" id="LN965">965</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>double</span> *genPulseFromFourierMag(EST_Track *mag, <span class='keyword'>int</span> n, <span class='keyword'>double</span> f0, <span class='macro'>boolean<span class='expansion'>int</span></span> aperiodicFlag)</td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">{</td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">        </td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">    <span class='keyword'>int</span> numHarm = mag-&gt;num_channels();</td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">    <span class='keyword'>int</span> currentF0 = (<span class='keyword'>int</span>)round(f0);</td></tr>
<tr><td class="num" id="LN971">971</td><td class="line">    <span class='keyword'>int</span> T, T2;</td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">    <span class='keyword'>double</span> *pulse = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN973">973</td><td class="line">      </td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">    <span class='keyword'>if</span>(currentF0 &lt; 512)</td></tr>
<tr><td class="num" id="LN975">975</td><td class="line">        T = 512;</td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN977">977</td><td class="line">        T = 1024;</td></tr>
<tr><td class="num" id="LN978">978</td><td class="line">    T2 = 2*T;</td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">      </td></tr>
<tr><td class="num" id="LN980">980</td><td class="line">    <span class='comment'>/* since is FFT2 no aperiodicFlag or jitter of 25% is applied */</span></td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">      </td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">    <span class='comment'>/* get the pulse */</span>      </td></tr>
<tr><td class="num" id="LN983">983</td><td class="line">    pulse = <span class='macro'>walloc(<span class='keyword'>double</span>,T)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(T)))</span></span>;</td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">    EST_FVector real(T2);</td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">    EST_FVector imag(T2);</td></tr>
<tr><td class="num" id="LN986">986</td><td class="line"> </td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">    <span class='comment'>/* copy Fourier magnitudes (Wai C. Chu "Speech Coding algorithms foundation and evolution of standardized coders" pg. 460) */</span></td></tr>
<tr><td class="num" id="LN988">988</td><td class="line">    real[0] = real[T] = 0.0;   <span class='comment'>/* DC component set to zero */</span></td></tr>
<tr><td class="num" id="LN989">989</td><td class="line">    <span class='keyword'>for</span>(i=1; i&lt;=numHarm; i++){     </td></tr>
<tr><td class="num" id="LN990">990</td><td class="line">        real[i] = real[T-i] = real[T+i] =  real[T2-i] = mag-&gt;a(n, i-1);  <span class='comment'>/* Symetric extension */</span></td></tr>
<tr><td class="num" id="LN991">991</td><td class="line">        imag[i] = imag[T-i] = imag[T+i] =  imag[T2-i] = 0.0;</td></tr>
<tr><td class="num" id="LN992">992</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN993">993</td><td class="line">    <span class='keyword'>for</span>(i=(numHarm+1); i&lt;(T-numHarm); i++){   <span class='comment'>/* Default components set to 1.0 */</span></td></tr>
<tr><td class="num" id="LN994">994</td><td class="line">        real[i] = real[T-i] = real[T+i] =  real[T2-i]  = 1.0;</td></tr>
<tr><td class="num" id="LN995">995</td><td class="line">        imag[i] = imag[T-i] = imag[T+i] =  imag[T2-i] = 0.0;</td></tr>
<tr><td class="num" id="LN996">996</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN997">997</td><td class="line">          </td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">    <span class='comment'>/* Calculate inverse Fourier transform */</span></td></tr>
<tr><td class="num" id="LN999">999</td><td class="line">    IFFT(real, imag);</td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line">    <span class='comment'>/* circular shift and normalise multiplying by sqrt(F0) */</span></td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line">    <span class='keyword'>double</span> sqrt_f0 = sqrt((<span class='keyword'>float</span>)currentF0); </td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt;T; i++)  </td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line">        pulse[i] = real[modShift(i-numHarm,T)] * sqrt_f0;</td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line">    <span class='keyword'>return</span> pulse;</td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line">    </td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line"><span class='keyword'>int</span> htsMLSAVocoder(EST_Track *lf0Pst, </td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line">                   EST_Track *mcepPst, </td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line">                   EST_Track *strPst, </td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">                   EST_Track *magPst, </td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">                   <span class='keyword'>int</span> *voiced,</td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">                   HTSData *htsData,</td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">                   EST_Wave *wave)</td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line">    <span class='keyword'>double</span> inc, x;</td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">    <span class='keyword'>double</span> xp=0.0,xn=0.0,fxp,fxn,mix;  <span class='comment'>/* samples for pulse and for noise and the filtered ones */</span></td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">    <span class='keyword'>int</span> i, j, k, m, s, mcepframe, lf0frame, s_double; </td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line">    <span class='keyword'>double</span> alpha = htsData-&gt;alpha;</td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line">    <span class='keyword'>double</span> beta  = htsData-&gt;beta;</td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line">    <span class='keyword'>double</span> aa = 1-alpha*alpha;</td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line">    <span class='keyword'>int</span> audio_size;                    <span class='comment'>/* audio size in samples, calculated as num frames * frame period */</span></td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line">    <span class='keyword'>double</span> *audio_double = <span class='macro'>NULL<span class='expansion'>__null</span></span>;</td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line">    <span class='keyword'>double</span> *magPulse = <span class='macro'>NULL<span class='expansion'>__null</span></span>;         <span class='comment'>/* pulse generated from Fourier magnitudes */</span></td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line">    <span class='keyword'>int</span> magSample, magPulseSize;</td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line">    <span class='macro'>boolean<span class='expansion'>int</span></span> aperiodicFlag = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line">    <span class='keyword'>double</span> *d;                        <span class='comment'>/* used in the lpc vocoder */</span></td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line">    <span class='keyword'>double</span> f0, f0Std, f0Shift, f0MeanOri;</td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line">    <span class='keyword'>double</span> *mc = <span class='macro'>NULL<span class='expansion'>__null</span></span>; <span class='comment'>/* feature vector for a particular frame */</span></td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line">    <span class='keyword'>double</span> *hp = <span class='macro'>NULL<span class='expansion'>__null</span></span>; <span class='comment'>/* pulse shaping filter, initialised once it is known orderM */</span>  </td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line">    <span class='keyword'>double</span> *hn = <span class='macro'>NULL<span class='expansion'>__null</span></span>; <span class='comment'>/* noise shaping filter, initialised once it is known orderM */</span>  </td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">    <span class='comment'>/* Initialise vocoder and mixed excitation, once initialised it is known the order</span></td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line">     <span class='comment'>* of the filters so the shaping filters hp and hn can be initialised. */</span></td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line">    m = mcepPst-&gt;num_channels();</td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line">    mc = <span class='macro'>walloc(<span class='keyword'>double</span>,m)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(m)))</span></span>;</td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line">    initVocoder(m-1, mcepPst-&gt;num_frames(), htsData);</td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line">    d = <span class='macro'>walloc(<span class='keyword'>double</span>,m)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(m)))</span></span>;</td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line">    <span class='keyword'>if</span> (lpcVocoder)</td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line">    {</td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line">        <span class='comment'>/*        printf("Using LPC vocoder\n");  */</span></td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line">        <span class='keyword'>for</span>(i=0; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line">            d[i] = 0.0;</td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line">    mixedExcitation = htsData-&gt;useMixExc;</td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line">    fourierMagnitudes = htsData-&gt;useFourierMag;</td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line">         </td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line">    <span class='keyword'>if</span> ( mixedExcitation )</td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line">    {  </td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line">        numM = htsData-&gt;NumFilters;</td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line">        orderM = htsData-&gt;OrderFilters;</td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line">        xpulseSignal = <span class='macro'>walloc(<span class='keyword'>double</span>,orderM)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(orderM)))</span></span>;</td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line">        xnoiseSignal = <span class='macro'>walloc(<span class='keyword'>double</span>,orderM)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(orderM)))</span></span>;</td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line">        <span class='comment'>/* initialise xp_sig and xn_sig */</span></td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line">        <span class='keyword'>for</span>(i=0; i&lt;orderM; i++)</td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line">            xpulseSignal[i] = xnoiseSignal[i] = 0;    </td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line">        h = htsData-&gt;MixFilters;</td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line">        hp = <span class='macro'>walloc(<span class='keyword'>double</span>,orderM)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(orderM)))</span></span>;</td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line">        hn = <span class='macro'>walloc(<span class='keyword'>double</span>,orderM)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(orderM)))</span></span>; </td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line">              </td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line">        <span class='comment'>//Check if the number of filters is equal to the order of strpst </span></td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line">        <span class='comment'>//i.e. the number of filters is equal to the number of generated strengths per frame.</span></td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line">        <span class='keyword'>if</span>(numM != strPst-&gt;num_channels()) {</td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line">            printf(<span class='string_literal'>"htsMLSAVocoder: error num mix-excitation filters = %d "</span></td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line">                   <span class='string_literal'>" in configuration file is different from generated str order= %d\n"</span>,</td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line">                   numM, strPst-&gt;num_channels());</td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line">        printf(<span class='string_literal'>"HMM speech generation with mixed-excitation.\n"</span>);</td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">    } </td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line"><span class='directive'>#if 0</span></td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line">        printf(<span class='string_literal'>"HMM speech generation without mixed-excitation.\n"</span>);  </td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">    <span class='keyword'>if</span>( fourierMagnitudes &amp;&amp; htsData-&gt;PdfMagFile != <span class='macro'>NULL<span class='expansion'>__null</span></span>)</td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line">        printf(<span class='string_literal'>"Pulse generated with Fourier Magnitudes.\n"</span>);</td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line">        printf(<span class='string_literal'>"Pulse generated as a unit pulse.\n"</span>);</td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line">    <span class='keyword'>if</span>(beta != 0.0)</td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">        printf(<span class='string_literal'>"Postfiltering applied with beta=%f"</span>,(<span class='keyword'>float</span>)beta);</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line">        printf(<span class='string_literal'>"No postfiltering applied.\n"</span>);</td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line">    <span class='comment'>/* Clear content of c, should be done if this function is</span></td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line">       <span class='comment'>called more than once with a new set of generated parameters. */</span></td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt; C_length; i++)</td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line">        C[i] = CC[i] = CINC[i] = 0.0;</td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">    <span class='keyword'>for</span>(i=0; i&lt; D1_length; i++)</td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line">        D1[i]=0.0;</td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line">    </td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line">    f0Std = htsData-&gt;F0Std;</td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">    f0Shift = htsData-&gt;F0Mean;</td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">    f0MeanOri = 0.0;</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line">    <span class='comment'>/* XXX */</span></td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line">    <span class='keyword'>for</span> (mcepframe=0,lf0frame=0; mcepframe&lt;mcepPst-&gt;num_frames(); mcepframe++) </td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line">    {</td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line">        <span class='keyword'>if</span>(voiced[mcepframe])</td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line">        {   <span class='comment'>/* WAS WRONG */</span></td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line">            f0MeanOri = f0MeanOri + lf0Pst-&gt;a(mcepframe, 0);</td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line">            lf0frame++;</td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line">    f0MeanOri = f0MeanOri/lf0frame;</td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line">   </td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line">    <span class='comment'>/* ____________________Synthesize speech waveforms_____________________ */</span></td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line">    <span class='comment'>/* generate Nperiod samples per mcepframe */</span></td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line">    s = 0;   <span class='comment'>/* number of samples */</span></td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line">    s_double = 0;</td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line">    audio_size = mcepPst-&gt;num_frames() * (fprd);</td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line">    audio_double = <span class='macro'>walloc(<span class='keyword'>double</span>,audio_size)<span class='expansion'>((double *)safe_walloc(sizeof(double)*(audio_size)))</span></span>;  <span class='comment'>/* initialise buffer for audio */</span></td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line">    magSample = 1;</td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line">    magPulseSize = 0;</td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line">    <span class='keyword'>for</span>(mcepframe=0,lf0frame=0; mcepframe&lt;mcepPst-&gt;num_frames(); mcepframe++) </td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line">    { </td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line">        <span class='comment'>/* get current feature vector mcp */</span> </td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line">        <span class='keyword'>for</span>(i=0; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line">            mc[i] = mcepPst-&gt;a(mcepframe, i); </td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line">   </td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">        <span class='comment'>/* f0 modification through the MARY audio effects */</span></td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line">        <span class='keyword'>if</span>(voiced[mcepframe]){</td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line">            f0 = f0Std * lf0Pst-&gt;a(mcepframe, 0) + (1-f0Std) * f0MeanOri + f0Shift;       </td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">            lf0frame++;</td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">            <span class='keyword'>if</span>(f0 &lt; 0.0)</td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">                f0 = 0.0;</td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line">        <span class='keyword'>else</span>{</td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line">            f0 = 0.0;          </td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line">         </td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line">        <span class='comment'>/* if mixed excitation get shaping filters for this frame */</span></td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">        <span class='keyword'>if</span> (mixedExcitation)</td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">        {</td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">            <span class='keyword'>for</span>(j=0; j&lt;orderM; j++) </td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">            {</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line">                hp[j] = hn[j] = 0.0;</td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line">                <span class='keyword'>for</span>(i=0; i&lt;numM; i++) </td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line">                {</td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line">                    hp[j] += strPst-&gt;a(mcepframe, i) * h[i][j];</td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">                    hn[j] += ( 1 - strPst-&gt;a(mcepframe, i) ) * h[i][j];</td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line">        <span class='comment'>/* f0-&gt;pitch, in original code here it is used p, so f0=p in the c code */</span></td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">        <span class='keyword'>if</span>(f0 != 0.0)</td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line">            f0 = rate/f0;</td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line">        <span class='comment'>/* p1 is initialised in -1, so this will be done just for the first frame */</span></td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line">        <span class='keyword'>if</span>( p1 &lt; 0 ) {  </td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line">            p1   = f0;           </td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line">            pc   = p1;   </td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line">            <span class='comment'>/* for LSP */</span></td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line">            <span class='keyword'>if</span>(stage != 0){</td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line">                <span class='keyword'>if</span>( use_log_gain)</td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line">                    C[0] = LZERO;</td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line">                <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line">                    C[0] = ZERO;</td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">                <span class='keyword'>for</span>(i=0; i&lt;m; i++ )  </td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">                    C[i] = i * <span class='macro'>PI<span class='expansion'>3.14159265358979323846</span></span> / m;</td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">                <span class='comment'>/* LSP -&gt; MGC */</span></td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">                lsp2mgc(C, C, (m-1), alpha);</td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line">                mc2b(C, C, (m-1), alpha);</td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line">                gnorm(C, C, (m-1), xgamma);</td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line">                <span class='keyword'>for</span>(i=1; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">                    C[i] *= xgamma;   </td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line">        <span class='keyword'>if</span>(stage == 0){         </td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line">            <span class='comment'>/* postfiltering, this is done if beta&gt;0.0 */</span></td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line">            postfilter_mcp(mc, (m-1), alpha, beta);</td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line">            <span class='comment'>/* mc2b: transform mel-cepstrum to MLSA digital filter coefficients */</span>   </td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line">            mc2b(mc, CC, (m-1), alpha);</td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line">            <span class='keyword'>for</span>(i=0; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line">                CINC[i] = (CC[i] - C[i]) * iprd / fprd;</td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line">            lsp2mgc(mc, CC, (m-1), alpha );</td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line">            mc2b(CC, CC, (m-1), alpha);</td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line">         </td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line">            gnorm(CC, CC, (m-1), xgamma);</td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line">         </td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line">            <span class='keyword'>for</span>(i=1; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line">                CC[i] *= xgamma;</td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line">         </td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line">            <span class='keyword'>for</span>(i=0; i&lt;m; i++)</td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line">                CINC[i] = (CC[i] - C[i]) * iprd / fprd;</td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line">        } </td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line">        <span class='comment'>/* p=f0 in c code!!! */</span></td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line">        <span class='keyword'>if</span>( p1 != 0.0 &amp;&amp; f0 != 0.0 ) {</td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line">            inc = (f0 - p1) * (<span class='keyword'>double</span>)iprd/(<span class='keyword'>double</span>)fprd;</td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line">            <span class='comment'>//System.out.println("  inc=(f0-p1)/80=" + inc );</span></td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line">            inc = 0.0;</td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line">            pc = f0;</td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line">            p1 = 0.0; </td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">              </td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line">        <span class='comment'>/* Here need to generate both xp:pulse and xn:noise signals seprately*/</span> </td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line">        gauss = <span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>; <span class='comment'>/* Mixed excitation works better with nomal noise */</span></td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">        <span class='comment'>/* Generate fperiod samples per feature vector, normally 80 samples per frame */</span></td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line">        <span class='comment'>//p1=0.0;</span></td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line">        gauss=<span class='keyword'><span class='macro'>false<span class='expansion'>0</span></span></span>;</td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line">        <span class='keyword'>for</span>(j=fprd-1, i=(iprd+1)/2; j&gt;=0; j--) {          </td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line">            <span class='keyword'>if</span>(p1 == 0.0) {</td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line">                <span class='keyword'>if</span>(gauss)</td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line">                    x = 0 <span class='comment'>/* rand.nextGaussian() */</span>;  <span class='comment'>/* XXX returns double, gaussian distribution mean=0.0 and var=1.0 */</span></td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line">                <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line">                    x = uniformRand(); <span class='comment'>/* returns 1.0 or -1.0 uniformly distributed */</span></td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line">            </td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line">                <span class='keyword'>if</span>(mixedExcitation) {</td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">                    xn = x;</td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line">                    xp = 0.0;</td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line">                <span class='keyword'>if</span>( (pc += 1.0) &gt;= p1 ){</td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">                    <span class='keyword'>if</span>(fourierMagnitudes){</td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">                        <span class='comment'>/* jitter is applied just in voiced frames when the stregth of the first band is &lt; 0.5*/</span></td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line">                        <span class='comment'>/* this will work just if Radix FFT is used */</span>  </td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line">                        <span class='comment'>/*if(strPst.getPar(mcepframe, 0) &lt; 0.5)</span></td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line">                          <span class='comment'>aperiodicFlag = true;</span></td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line">                          <span class='comment'>else</span></td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line">                          <span class='comment'>aperiodicFlag = false;</span>          </td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line">                          <span class='comment'>magPulse = genPulseFromFourierMagRadix(magPst, mcepframe, p1, aperiodicFlag);</span></td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line">                        <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">                    </td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line">                        magPulse = genPulseFromFourierMag(magPst, mcepframe, p1, aperiodicFlag);</td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line">                        magSample = 0;</td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">                        magPulseSize = -27 <span class='comment'>/* magPulse.length*/</span>; <span class='comment'>/** XXX **/</span></td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">                        x = magPulse[magSample];</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line">                        magSample++;</td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line">                    } <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">                        x = sqrt(p1);  </td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line">                    pc = pc - p1;</td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line">                } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line">                </td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line">                    <span class='keyword'>if</span>(fourierMagnitudes){</td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line">                        <span class='keyword'>if</span>(magSample &gt;= magPulseSize ){ </td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line">                            x = 0.0;</td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line">                        }</td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line">                        <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line">                            x = magPulse[magSample];                </td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line">                        magSample++;</td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line">                    } <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line">                        x = 0.0;                 </td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line">              </td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line">                <span class='keyword'>if</span>(mixedExcitation) {</td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line">                    xp = x;</td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line">                    <span class='keyword'>if</span>(gauss)</td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line">                        xn = 0 <span class='comment'>/* rand.nextGaussian() */</span> ; <span class='comment'>/* XXX */</span></td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line">                    <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line">                        xn = uniformRand();</td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line">            } </td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line">            <span class='comment'>/* apply the shaping filters to the pulse and noise samples */</span></td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line">            <span class='comment'>/* i need memory of at least for M samples in both signals */</span></td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line">            <span class='keyword'>if</span>(mixedExcitation) {</td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line">                fxp = 0.0;</td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line">                fxn = 0.0;</td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line">                <span class='keyword'>for</span>(k=orderM-1; k&gt;0; k--) {</td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line">                    fxp += hp[k] * xpulseSignal[k];</td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line">                    fxn += hn[k] * xnoiseSignal[k];</td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line">                    xpulseSignal[k] = xpulseSignal[k-1];</td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line">                    xnoiseSignal[k] = xnoiseSignal[k-1];</td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line">                fxp += hp[0] * xp;</td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line">                fxn += hn[0] * xn;</td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line">                xpulseSignal[0] = xp;</td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line">                xnoiseSignal[0] = xn;</td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">                <span class='comment'>/* x is a pulse noise excitation and mix is mixed excitation */</span></td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line">                mix = fxp+fxn;</td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">                <span class='comment'>/* comment this line if no mixed excitation, just pulse and noise */</span></td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line">                x = mix;   <span class='comment'>/* excitation sample */</span></td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line">                <span class='comment'>/*                printf("awb_debug me %d %f\n",(int)(s_double),(float)x); */</span></td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line">           </td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line">            <span class='keyword'>if</span>(lpcVocoder){</td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line">                <span class='comment'>// LPC filter  C[k=0] = gain is not used!</span></td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line">                <span class='keyword'>if</span>(!NGAIN)</td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line">                    x *= C[0];</td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line">                <span class='keyword'>for</span>(k=(m-1); k&gt;1; k--){</td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line">                    x = x - (C[k] * d[k]);</td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line">                    d[k] = d[k-1];</td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line">                x = x - (C[1] * d[1]);</td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line">                d[1] = x;</td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line">               </td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line">            } <span class='keyword'>else</span> <span class='keyword'>if</span>(stage == 0 ){</td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line">                <span class='keyword'>if</span>(x != 0.0 )</td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line">                    x *= exp(C[0]);</td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line">                x = mlsadf(x, C, m, alpha, aa, D1);</td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line">            </td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line">                <span class='keyword'>if</span>(!NGAIN)</td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line">                    x *= C[0];</td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line">                x = mglsadf(x, C, (m-1), alpha, stage, D1);</td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line">            }</td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line">            audio_double[s_double] = x;</td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line">            s_double++;</td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line">          </td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line">            <span class='keyword'>if</span>((--i) == 0 ) {</td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line">                p1 += inc;</td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line">                <span class='keyword'>for</span>(k=0; k&lt;m; k++){</td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line">                    C[k] += CINC[k];  </td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line">                }</td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line">                i = iprd;</td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line">            }          </td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line">        } <span class='comment'>/* for each sample in a period fprd */</span></td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line">        p1 = f0;</td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line">     </td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line">        <span class='comment'>/* move elements in c */</span></td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line">        <span class='comment'>/* HTS_movem(v-&gt;cc, v-&gt;c, m + 1); */</span></td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line">        <span class='keyword'>for</span>(i=0; i&lt;m; i++){</td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line">            C[i] = CC[i];  </td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line">    } <span class='comment'>/* for each mcep frame */</span></td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line">    </td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line">    <span class='comment'>/*    printf("Finish processing %d mcep frames.\n",mcepframe); */</span></td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line">    </td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line">    wave-&gt;resize(audio_size,1);</td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line">    <span class='keyword'>for</span> (i=0; i&lt;s_double; i++)</td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line">        wave-&gt;a(i) = (<span class='keyword'>short</span>)audio_double[i];</td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line">        </td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line">      </td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line">} <span class='comment'>/* method htsMLSAVocoder() */</span></td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line">    </td></tr>
</table></body></html>
